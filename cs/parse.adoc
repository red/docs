= Dialekt Parse
:imagesdir: ../images
:toc:
:toclevels: 3
:numbered:

== PÅ™ehled


Dialekt Parse je jazyk specifickÃ© domÃ©ny (domain-specific language - DSL) programovacÃ­ho jazyka Red, kterÃ½ umoÅ¾Åˆuje struÄnÃ© a pÅ™esnÃ© zpracovÃ¡nÃ­ vstupÅ¯ (_input_) podle gramatickÃ½ch pravidel (_rules_). ObvyklÃ© pÅ™Ã­pady pouÅ¾itÃ­ DSL Parse jsou tyto:

* *HledÃ¡nÃ­:* lokalizace zadanÃ½ch vzorÅ¯;
* *Validace*: ovÄ›Å™enÃ­ shody vstupu s urÄitou specifikacÃ­;
* *VyjmutÃ­*: pÅ™efiltrovÃ¡nÃ­ dat a agregace hodnot (e.g. scraping);
* *Modifikace*: transformace dat (vloÅ¾enÃ­ hodnot, odejmutÃ­ a zmÄ›na shodujÃ­cÃ­ch se vstupÅ¯);
* *ZpracovÃ¡nÃ­ jazyka*: pouÅ¾itÃ­ kompilÃ¡torÅ¯, interpretÅ¯ a lexikÃ¡lnÃ­ch analyzÃ¡torÅ¯, zvlÃ¡Å¡tÄ› pro DSL;
* *KÃ³dovÃ¡nÃ­ a dekÃ³dovÃ¡nÃ­*: konverze datovÃ½ch formÃ¡tÅ¯ z jednoho do druhÃ©ho.

=== PouÅ¾itÃ­

ParsovÃ¡nÃ­ se invokuje funkcÃ­ `parse` s pouÅ¾itÃ­m jednoduchÃ© implicitnÃ­ syntaxe (podrobnÄ›ji viz sekce <<Extra functions>>):

----
parse <input> <rules>

<input> : jakÃ¡koli hodnota typu series! kromÄ› image! a vector!
<rules> : hodnota typu block!, obsahujÃ­cÃ­ platnÃ½ dialekt Parse (top-level rule)
----

ImplicitnÄ› vracÃ­ `parse` hodnotu typu `logic!` jako sdÄ›lenÃ­, zda zadanÃ¡ gramatickÃ¡ pravidla byla v ÃºplnÃ© shodÄ› se zadanÃ½m vstupem.

=== ZÃ¡kladnÃ­ principy

GramatickÃ¡ pravidla pro parsovÃ¡nÃ­ definujÃ­ vzory, pouÅ¾itÃ© pro vstÅ™ebÃ¡nÃ­ (_consume_) vstupnÃ­ch Å™ad. ZÃ¡kladnÃ­ vyhodnocovacÃ­ krok dialektu Parse je pravidlo _match_, kterÃ© mÃ¡ jeden z tÄ›chto dvou vÃ½stupÅ¯:

* Pokud se danÃ© pravidlo shoduje, je ÃºspÄ›Å¡nÃ© (it _succeeds_) a Parse (nepovinnÄ›) postoupÃ­ (_advances_) za shodujÃ­cÃ­ se porci vstupu i pravidla;
* NenÃ­-li shoda, pravidlo selhÃ¡vÃ¡ (_fails_), naÄeÅ¾ Parse couvne (_backtracks_) a vrÃ¡tÃ­ se k _alternativnÃ­m_ pravidlÅ¯m (pokud existujÃ­).

ZpracovÃ¡nÃ­ vstupu (_parsing_) je ÄasovÄ› nemomezenÃ¡ aplikace tohoto zÃ¡kladnÃ­ho kroku, kterÃ½ je zastaven jednou z nÃ¡sledujÃ­cÃ­ch dvou ukonÄujÃ­cÃ­ch podmÃ­nek:

* NeÃºspÄ›Å¡nÃ¡ aplikace pravidla: `parse` vracÃ­ `false`, signalizujÃ­ce neshodu;
* ÃšplnÃ¡ shoda pravidla s porovnÃ¡vanÃ½m vstupem  (to jest dosaÅ¾enÃ­ konce zkoumanÃ© Å™ady): `parse` vracÃ­ `true`, signalizujÃ­ce shodu.

POZOR: NenÃ­-li splnÄ›na Å¾Ã¡dnÃ¡ z uvedenÃ½ch ukonÄovacÃ­ch podmÃ­nek, mÅ¯Å¾e vstoupit Parse do nekoneÄnÃ© smyÄky.

=== GlosÃ¡Å™

Dialekt parse je vylepÅ¡enÃ½ Älen rodiny formÃ¡lnÃ­ch jazykÅ¯ https://en.wikipedia.org/wiki/Parsing_expression_grammar[Parsing Expression Grammar] (PEG), odliÅ¡ujÃ­cÃ­ se Å¡irokou sadou vlastnostÃ­ a hlubokou integracÃ­ s jazykem Red, avÅ¡ak sdÃ­lejÃ­cÃ­ obecnÃ© vÃ½znamy zÃ¡kladnÃ­ch konstrukcÃ­ a operacÃ­:

GramatickÃ¡ pravidla::
    HierarchickÃ© vÃ½razy s prakticky neomezenou skladebnostÃ­. Jejich skladba a sÃ©mantika jsou popsÃ¡ny v sekci <<Pravidla jazyka Parse>>.

Advancing::
    ProchÃ¡zenÃ­ vstupnÃ­ Å™adou postupnÃ½m ovÄ›Å™ovÃ¡nÃ­m shody jednotlivÃ©ho elementu s gramatickÃ½mi pravidly aÅ¾ ke konci Å™ady nebo k vÃ½skytu neshody.

Fetching::
    VyhledÃ¡nÃ­ nÃ¡slednÃ©ho uplatnitelnÃ©ho pravidla za ÃºspÄ›Å¡nou shodou.

Alternating (v PEG popsÃ¡no jako _ordered choice_)::
    V pÅ™Ã­padÄ› vÃ½skytu neshody s pravidlem se postupnÄ› pokouÅ¡et o shodu s nÃ¡sledujÃ­cÃ­mi alternativnÃ­mi pravidly v tÃ©mÅ¾e bloku za znakem `|` ("pipe", "bar", "nebo").
Backtracking::
    VrÃ¡cenÃ­ vstupu a pravidel na pozici pÅ™ed selhÃ¡nÃ­m pravidla. OstatnÃ­ zmÄ›ny (vedlejÅ¡Ã­ ÃºÄinky a Ãºpravy vstupu Äi pravidel) zÅ¯stÃ¡vajÃ­.

Possessive matching::
    ParsovacÃ­ pravidla (hlavnÄ› <<Repetition>>) se vÅ¾dycky snaÅ¾Ã­ posoudit co nejvÃ­ce vstupnÃ­ch dat.

== ReÅ¾imy parsovÃ¡nÃ­

Dialekt Parse nabÃ­zÃ­ jistÃ½ stupeÅˆ flexibility provedenÃ­ podporou rÅ¯znÃ½ch reÅ¾imÅ¯.

=== Case-sensitivity

ImplicitnÄ› mÃ¡ Parse shodnou sÃ©mantiku jako Red a je  case-insensitive. VnÃ­mÃ¡nÃ­ velkÃ½ch pÃ­smen lze umoÅ¾nit upÅ™esnÄ›nÃ­m `/case` nebo vypnout/zapnout klÃ­ÄovÃ½m slovem `case`.

*Syntaxe*

----
case <word>

<word> : word! value
----

S hodnotou, na nÃ­Å¾ odkazuje word se zachÃ¡zÃ­ jako s logickÃ½m praporkem (flag) podle standardnÃ­ sÃ©mantiky Redu. LogickÃ© true umoÅ¾Åˆuje case-sensitivnÃ­ reÅ¾im, zatÃ­mco logickÃ© false jej znemoÅ¾Åˆuje.

=== SbÄ›rnÃ½ reÅ¾im

Pravidlo `collect` pÅ™ikazuje, aby `parse` vrÃ¡tilo blok mÃ­sto hodnoty `logic!`. Detaily lze nalÃ©zt v sekci <<Extraction>> section.

=== Typy vstupu

V zÃ¡vislosti na typu vstupnÃ­ch Å™ad nejsou nÄ›kterÃ¡ pravidla Parse uplatnitelnÃ¡ nebo se chovajÃ­ odliÅ¡nÄ›.

* `any-block!`:
    ** VyhledÃ¡vÃ¡nÃ­ shody se sadou znakÅ¯ nemÃ¡ Å¾Ã¡dnÃ½ vÃ½znam a vÅ¾dycky selÅ¾e;
* `any-string!` a `binary!`:
    ** PorovnÃ¡vÃ¡nÃ­ s datovÃ½m typem nebo se sadou typÅ¯ nenÃ­ podporovÃ¡no.

== ParsovacÃ­ pravidla

GramatickÃ¡ pravidla v dialektu Parse mohou mÃ­t nÄ›kolik forem a obvykle majÃ­ vnoÅ™enou nebo rekurzivnÃ­ strukturu. KaÅ¾dÃ© pravidlo je jednÃ­m z nÃ¡sledujÃ­cÃ­ch:

* Dialektem rezervovanÃ© _klÃ­ÄovÃ© slovo_, volitelnÄ› nÃ¡sledovanÃ© argumenty nebo moÅ¾nostmi (viz nÃ­Å¾e).
* Hodnota nÄ›kterÃ©ho z nÃ¡sledujÃ­cÃ­ch datovÃ½ch typÅ¯:
    ** `datatype!` nebo `typeset!` - porovnÃ¡vÃ¡ vstupnÃ­ hodnotu s jejÃ­m <<Datatype, typem>>;   
	** `bitset!` - reprezentuje <<Character set, znakovou sadu>>;
    ** `word!` - odkazuje na well-formed sub-rule;
    ** `lit-word!` nebo `lit-path!` â€” zavedenÃ© zkratky pro <<Literal value, doslovnou shodu>> vstupnÃ­ch hodnot typu `word!` pÅ™Ã­padnÄ› `path!`;
    ** `set-word!` - se pouÅ¾Ã­vÃ¡ k <<Marking, nastavenÃ­>> slova na aktuÃ¡lnÃ­ vstupnÃ­ pozici;
    ** `get-word!` - <<Restoring, vrÃ¡tÃ­>> pozici vstupu k dÅ™Ã­ve nastavenÃ©mu slovu;
    ** `block!` - hodnota, kterÃ¡ obsahuje libovolnÃ½ poÄet sub-pravidel a znakÅ¯ `|`, jeÅ¾ pÅ¯sobÃ­ jako oddÄ›lovaÄe pro alternativnÃ­ pravidla;
    ** `integer!` - hodnota, kterÃ¡ slouÅ¾Ã­ jako poÄÃ­tadlo pro
	value, serves as a counter for <<Iteration count, opakovÃ¡nÃ­>> pravidla; dvÄ› nÃ¡sledujÃ­cÃ­ hodnoty typu  `integer!` oznaÄujÃ­ rozsah moÅ¾nÃ½ch iteracÃ­;
    ** `paren!` - hodnota, kterÃ¡ pÅ¯sobÃ­ jako 	 <<Expression evaluation, ÃºnikovÃ½ mechanizmus>> dialektu vyhodnocenÃ­m obsaÅ¾enÃ©ho vÃ½razu Red a pokraÄovÃ¡nÃ­m v parsovÃ¡nÃ­ vstupu; nÄ›kterÃ¡ klÃ­ÄovÃ¡ slova Parse pouÅ¾Ã­vajÃ­ vrÃ¡cenÃ© hodnoty z vÃ½raz ve shodÄ› se svou vlastnÃ­ sÃ©mantikou;
* JakÃ¡koliv jinÃ¡ literÃ¡lovÃ¡ hodnota vÃ½Å¡e nezmÃ­nÄ›nÃ¡, jeÅ¾ se pouÅ¾Ã­vÃ¡ jak-je pro pÅ™Ã­mÃ© porovnÃ¡vÃ¡nÃ­ se vstupem.

NOTE: Parse je konsistentnÃ­ s Redem v pouÅ¾Ã­vÃ¡nÃ­ volnÃ½ch komparacÃ­ pro porovnÃ¡vÃ¡nÃ­ s literÃ¡lovÃ½mi hodnotami.

KaÅ¾dÃ© pravidlo (rule) je charakterizovÃ¡no podmÃ­nkami, pÅ™i kterÃ½ch pokroÄÃ­ vstupem a uspÄ›je. PÅ™ehled pravidel dialektu Parse (jak vyhraÅ¾enÃ¡, tak klÃ­ÄovÃ¡ slova) je tabelÃ¡rnÄ› uveden nÃ­Å¾e.

.PÅ™ehled pravidel dialektu Parse.
[options="header" cols="2,3,2,2"]
|===
| Pravidlo | Categorie | PokroÄÃ­ | UspÄ›je

| `case`
| <<Parsing modes>>
| Never
| Always

| `block!`
| <<Composition>>
| Depends
| Depends

| `word!`
| <<Composition>>
| Depends
| Depends

| Literal value
| <<Direct matching>>
| Depends
| Depends

| `lit-word!`
| <<Direct matching>>
| Depends
| Depends

| `lit-path!`
| <<Direct matching>>
| Depends
| Depends

| `datatype!`
| <<Direct matching>>
| Depends
| Depends

| `typeset!`
| <<Direct matching>>
| Depends
| Depends

| `bitset!`
| <<Direct matching>>
| Depends
| Depends

| `quote`
| <<Direct matching>>
| Depends
| Depends

| `skip`
| <<Direct matching>>
| Depends
| Depends

| `none`
| <<Direct matching>>
| Never
| Always

| `end`
| <<Direct matching>>
| Never
| Depends

| `opt`
| <<Look-ahead>>
| Depends
| Always

| `not`
| <<Look-ahead>>
| Never
| Depends

| `ahead`
| <<Look-ahead>>
| Never
| Depends

| `paren!`
| <<Expression evaluation>>
| Never
| Always

| `set-word!`
| <<Positioning>>
| Never
| Always

| `get-word!`
| <<Positioning>>
| Depends
| Always

| `integer!`
| <<Repetition>>
| Depends
| Depends

| `any`
| <<Repetition>>
| Depends
| Always

| `some`
| <<Repetition>>
| Depends
| Depends

| `while`
| <<Repetition>>
| Depends
| Always

| `to`
| <<Search>>
| Depends
| Depends

| `thru`
| <<Search>>
| Depends
| Depends

| `if`
| <<Control flow>>
| Never
| Depends

| `into`
| <<Control flow>>
| Depends
| Depends

| `fail`
| <<Control flow>>
| Never
| Never

| `break`
| <<Control flow>>
| Never
| Always

| `reject`
| <<Control flow>>
| Never
| Never

| `set`
| <<Extraction>>
| Depends
| Depends

| `copy`
| <<Extraction>>
| Depends
| Depends

| `collect`
| <<Extraction>>
| Depends
| Depends

| `keep`
| <<Extraction>>
| Depends
| Depends

| `remove`
| <<Modification>>
| Depends
| Depends

| `insert`
| <<Modification>>
| Always
| Always

| `change`
| <<Modification>>
| Depends
| Depends

|===

NOTE: VÅ¡echna pravidla v dÃ¡le uvedenÃ½ch odstavcÃ­ch se plnÄ› shodujÃ­ se svÃ½mi vstupy.

=== Skladba

Pravidla typu `block!` pÅ™Ã­mo  seskupujÃ­ ostatnÃ­ prvidla, jsouce prostÅ™edkem pro kombinaci.  Pravidla typu `word!` nepÅ™Ã­mo odkazujÃ­ na jinÃ¡ pravidla, jsouce tak prostÅ™edkem pro abstrakci. SpoleÄnÄ› tvoÅ™Ã­ zÃ¡klad mluvnickÃ© skladby dialektu Parse.

Na strukturÃ¡lnÃ­ Ãºrovni je gramatika dialektu Parse sloÅ¾ena ze _sekvencÃ­_ a _alternativ_.

* Sekvence pravidel je skupina nula Äi vÃ­ce pravidel, individuelnÄ› ukonÄenÃ½ch _koncem_ pravidla. Tato sekvence je ÃºspÄ›Å¡nÃ¡, dospÄ›je-li (postupnÄ› ÃºspÄ›Å¡nou aplikacÃ­ svÃ½ch sub-pravidel) ke svÃ©mu konci. V pÅ™Ã­padÄ› selhÃ¡nÃ­ nÄ›kterÃ©ho sub-pravidla se proces parsovÃ¡nÃ­ vrÃ¡tÃ­ (backtracks) na poÄÃ¡tek neÃºspÄ›Å¡nÃ© sekvence.
* Koncem sekvence pravidel je buÄ konec obalujÃ­cÃ­ho bloku nebo _hraniÄnÃ­_ znak `|` (boundary word) alternativy.
* Alternativa je volitelnÃ¡ sekvence, kterou se Parse pokusÃ­ posoudit v pÅ™Ã­padÄ›, Å¾e pÅ™edchozÃ­ (to jest pÅ™ed hranicÃ­ `|`) sekvence selÅ¾e.

=== PÅ™Ã­mÃ© posouzenÃ­ shody

Pravidla, popsanÃ¡ v tÃ©to ÄÃ¡sti, pÅ™Ã­mo parsujÃ­ (posuzujÃ­ shodu) vstupnÃ­ data a slouÅ¾Ã­ jako zÃ¡kladnÃ­ stavebnÃ­ bloky pro sestavovÃ¡nÃ­ sloÅ¾itÄ›jÅ¡Ã­ch pravidel.

==== LiterÃ¡lovÃ© hodnoty
Parse je konsistentnÃ­ s Redem v pouÅ¾Ã­vÃ¡nÃ­ volnÃ½ch komparacÃ­ pro porovnÃ¡vÃ¡nÃ­ s literÃ¡lovÃ½mi hodnotami.

PosouzenÃ­ shody literÃ¡lovÃ© hodnoty je ÃºspÄ›Å¡nÃ© a vede k pokroÄenÃ­ zadanÃ½m vstupem, je-li posuzovanÃ¡ literÃ¡lovÃ¡ hodnota totoÅ¾nÃ¡ s hodnotou vstupu na aktuÃ¡lnÃ­ pozici.

NOTE: Parse implicitnÄ› pouÅ¾Ã­vÃ¡ volnou komparaci pro ovÄ›Å™enÃ­ rovnosti. <<Case-sensitivity, Case-sensitivnÃ­ reÅ¾im>> vynucuje case-sensitivnÃ­ porovnÃ¡nÃ­ (komparaci).

*PÅ™Ã­klad*

----
parse [today is 5-September-2012 #"," 20.3 degrees/celsius][
    'yesterday 'was | 'today 'is 05/09/12 comma 2030e-2 ['degrees/fahrenheit | 'degrees/celsius]
]
----

NOTE: Pro porovnÃ¡vÃ¡nÃ­ literÃ¡lovÃ½ch hodnot, vymezenÃ½ch v dialektu Parse, se jako ÃºnikovÃ½ mechanizmus pouÅ¾Ã­vÃ¡ klÃ­ÄovÃ© slovo `quote`.

==== Datatype

OvÄ›Å™enÃ­ shody podle datovÃ©ho typu je ÃºspÄ›Å¡nÃ© a vede k pokroÄenÃ­ vstupem, pokud je ovÄ›Å™ovanÃ¡ hodnota danÃ©ho typu.

*PÅ™Ã­klad*

----
parse [#a 'bird /is :the word][issue! lit-word! refinement! get-word! word!]
----

NOTE: OvÄ›Å™enÃ­ shody podle datovÃ©ho typu nenÃ­ podporovÃ¡no pro vstup typu `binary!` a `any-string!`.

==== Type set

OvÄ›Å™enÃ­ shody podle typovÃ© sady je ÃºspÄ›Å¡nÃ© a vede k pokroÄenÃ­ vstupem, jestliÅ¾e datovÃ½ typ vstupnÃ­ hodnoty patÅ™Ã­ k danÃ© typovÃ© sadÄ› (type set).

*PÅ™Ã­klad*

----
banner: [
               |
              [_]
             [___]
            [_____]
    Red programming language
    https://www.red-lang.org
]

parse banner [default! series! any-block! any-list! all-word! any-word! any-type! any-string!]
----

NOTE: OvÄ›Å™enÃ­ shody podle typovÃ© sady nenÃ­ podporovÃ¡no pro vstup typu `binary!` a `any-string!`.

==== Character set

Je-li vstupnÃ­ Å™ada typu `any-string!` nebo `binary!` a vstupnÃ­
hodnota reprezentuje Unicode Code Point (UCP), kterÃ½ patÅ™Ã­ k danÃ© sadÄ› znakÅ¯, potom je ovÄ›Å™enÃ­ shody ÃºspÄ›Å¡nÃ© a vede k pokroÄenÃ­ vstupem. Ve vÅ¡ech ostatnÃ­ch pÅ™Ã­padech je ovÄ›Å™enÃ­ shody neÃºspÄ›Å¡nÃ©.

Podrobnosti o vytvoÅ™enÃ­ datovÃ© sady lze nalÃ©zt v 
https://doc.red-lang.org/en/datatypes/bitset.html[documentaci] k datovÃ©mu typu `bitset!`.

*PÅ™Ã­klad*

----
animal: charset [#"ğŸ¦¢" #"^(1F418)" 128007]
follow: charset "ğŸš¶ğŸ‘£ğŸš¸"

parse "ğŸ‘£ the white ğŸ‡" [follow " the white " animal]
----

NOTE: Varianty _lowercase/uppercase_ tÃ©hoÅ¾ pÃ­smena majÃ­ rÅ¯znÃ¡ UCP. Z toho vyplÃ½vÃ¡, Å¾e ovÄ›Å™ovÃ¡nÃ­ shody podle znakovÃ© sady je _case-sensitive_ bez ohledu na <<Parsing modes, reÅ¾im parsovÃ¡nÃ­>>.

NOTE: Pro vstup typu `binary!` majÃ­ vÃ½znam pouze hodnoty UCP menÅ¡Ã­ neÅ¾ `255`, protoÅ¾e parsovÃ¡nÃ­ v tomto reÅ¾imu je _byte-granular_.

==== `quote`

PÅ¯sobÃ­ jako ÃºnikovÃ½ (escape) mechanizmus ze sÃ©mantiky dialektu Parse a to literÃ¡lovÃ½m ovÄ›Å™enÃ­m shody nÃ¡sledujÃ­cÃ­ hodnoty. Toto pravidlo je ÃºspÄ›Å¡nÃ© a vede k posunu vstupem, jestliÅ¾e je ovÄ›Å™enÃ­ shody ÃºspÄ›Å¡nÃ©.

*Syntaxe*

----
quote <value>

<value> : literal value to match
----

*PÅ™Ã­klad*

----
parse [[integer!] matches 20][quote [integer!] quote matches quote 20]
----

==== `skip`

Shoduje se s libobolnou hodnotou a pokroÄÃ­ vstupem. SelÅ¾e pouze v pÅ™Ã­padÄ›, kdy je pozice vstupu na chvostu (tail), protoÅ¾e tam nenÃ­ co posuzovat.

*PÅ™Ã­klad*

----
parse <ğŸ’“> [skip | the beat]
----

==== `none`

Pravidlo _no-op_ nebo _catch-all_, vÅ¾dy se shoduje a nikdy nevede k postupu vstupem.

*PÅ™Ã­klad*

----
parse reduce [none none][none #[none] ['none | none] none! none]
----

==== `end`

Pravidlo je ÃºspÄ›Å¡nÃ©, je-li pozice vstupu na jeho chvostu (tail) a nikdy nevede k postupu vstupem, protoÅ¾e jiÅ¾ nenÃ­ kam se posouvat.

*PÅ™Ã­klad*

----
parse [(ï¼Šâ—•á´—â—•ï¼Š)][end | skip [skip | end]]
----

=== Look-ahead

Pravidla s _pohledem vpÅ™ed_ (look-ahead) nabÃ­zejÃ­ podrobnÄ›jÅ¡Ã­ nastavenÃ­ ovÄ›Å™ovÃ¡nÃ­ shody, couvÃ¡nÃ­ (backtracking) a posunu vstupem.

==== `opt`

VolitelnÄ› posuzuje shodu s danÃ½m pravidlem, kterÃ¡ vede Äi nevede k posunu vstupem. Pravidlo je vÅ¾dy ÃºspÄ›Å¡nÃ© (== true) bez ohledu na shodu.

*Syntaxe*

----
opt <rule>

<rule> : Parse rule (option) to match
----

*PÅ™Ã­klad*

----
parse "maybe" [opt "or" "may" opt [#"b" #"e"] opt "not"]
----

==== `not`

Toto pravidlo (invertor) je ÃºspÄ›Å¡nÃ©, jestliÅ¾e zadanÃ© pravidlo selÅ¾e a opaÄnÄ›. Nikdy nevede k posunu vstupem, bez ohledu na shodu Äi neshodu.

*Syntaxe*

----
not <rule>

<rule> : Parse rule to invert
----

*PÅ™Ã­klad*

----
parse [panama][not 'man not ['plan | 'canal] not word! | skip]
----

==== `ahead`

PÅ™ednostnÄ› se shoduje s danÃ½m pravidlem. SelÅ¾e v pÅ™Ã­padÄ› selhÃ¡nÃ­ pravidla, jinak je ÃºspÄ›Å¡nÃ© bez posunu vstupem.

*Syntaxe*

----
ahead <rule>

<rule> : Parse rule to look ahead
----

*PÅ™Ã­klad*

----
parse [great times ahead][ahead ['great 'times] 'great ahead ['times ahead word! 'ahead] 'times skip] 
----

=== VyhodnocenÃ­ vÃ½razÅ¯

Pravidlo typu `paren!` obsahuje libovolnÃ½ vÃ½raz Redu, kterÃ½ se v pÅ™Ã­padÄ› shody vyhodnotÃ­. Toto pravidlo je vÅ¾dy ÃºspÄ›Å¡nÃ© ale nevede k postupu vstupem.

*PÅ™Ã­klad*

----
parse [(did it match?)][
    block! (not matched)
    | (probe 'backtracked) quote (did it match?) (probe 'matched!)
]
----

=== PozicovÃ¡nÃ­

Je moÅ¾nÃ© oznaÄit aktuÃ¡lnÃ­ pozici vstupu nebo _pÅ™etoÄit/rychle vpÅ™ed_ (rewind/fast-forward) na jinou pozici v tÃ©Å¾e vstupnÃ­ Å™adÄ›.

==== OznaÄenÃ­

Pravidlo typu `set-word!` nastavÃ­ slovo k aktuÃ¡lnÃ­ pozici vstupnÃ­ Å™ady. Je vÅ¾dy ÃºspÄ›Å¡nÃ© a nikdy nevede k postupu vstupem.

*PÅ™Ã­klad*

----
check: quote (probe reduce [start :failed before after current end])
match: [before: 'this none after:]

parse [match this input][
    start: quote [false start] failed:
    | ahead [skip match] current: ['match 'this 'input] end: check
]
----

==== PÅ™emÃ­stÄ›nÃ­

Pravidlo typu `get-word!` nastavÃ­ pozici vstupu na zmÃ­nÄ›nÃ© slovo. Je vÅ¾dy ÃºspÄ›Å¡nÃ© a buÄ posouvÃ¡ vpÅ™ed, zÅ¯stÃ¡vÃ¡ stÃ¡t nebo posouvÃ¡ vzad - v zÃ¡vislosti na postavenÃ­ markeru vzhledem k aktuÃ¡lnÃ­ pozici vstupu.

*PÅ™Ã­klad*

----
phrase: "and so on and so forth, 'til it gets boring"
goes: skip find phrase comma 2
end: tail phrase

parse phrase [again: "and" :again ['it | :goes] "until the" | :end]
----

NOTE: PÅ™emÃ­stÄ›nÃ­ pozice do jinÃ© Å™ady neÅ¾ vstupnÃ­ nenÃ­ dovoleno.

=== OpakovÃ¡nÃ­

Pravidla nÃ­Å¾e popsanÃ¡ pÅ¯sobÃ­ pÅ™i posouzenÃ­ shody jako smyÄky nebo iterÃ¡tory buÄ urÄenÃ½m poÄtem opakovÃ¡nÃ­ nebo aÅ¾ do dosaÅ¾enÃ­ neshody.

NOTE: OpakovacÃ­ pravidla majÃ­ vlastnickÃ© chovÃ¡nÃ­ a posoudÃ­ shodu co moÅ¾nÃ¡ nejrozsÃ¡hlejÅ¡Ã­ho vstupu.

==== PoÄet iteracÃ­

Provede posouzenÃ­ shody s danÃ½m pravidlem zadanÃ½m poÄtem opakovÃ¡nÃ­. Je-li pouÅ¾ita skladba range, je jako ÃºspÄ›Å¡nÃ½ akceptovÃ¡n libovolnÃ½ poÄet shod v zadanÃ©m rozsahu.

*Syntaxe*

----
<count> <rule>
<count> <count> <rule>

<count> : non-negative integer! value or word! referring to such value
<rule>  : Parse rule to match a specified number of times
----

NOTE: PÅ™i pouÅ¾itÃ­ skladby range, musÃ­ bÃ½t prvnÃ­ integer (spodnÃ­ mez) menÅ¡Ã­ nebo roven druhÃ©mu celÃ©mu ÄÃ­slu (hornÃ­ mez).

*PÅ™Ã­klad*

----
tuple:  [2 word!]
triple: [3 skip]
THX:    1138

parse [G A T T A C A][2 3 tuple triple | 0 thx [triple tuple] 1 tuple 0 triple]
----

==== Rekurze

Pravidla dialektu Parse lze rekurzivnÄ› sklÃ¡dat. ÃšroveÅˆ rekurze je limitovÃ¡na hloubkou internÃ­ pamÄ›ti stack.

*PÅ™Ã­klad*

----
ping: [none pong]
pong: [skip ping | end]

parse https://google.com ping
----

==== `any`

PorovnÃ¡ danÃ© pravidlo nula Äi vÃ­cekrÃ¡t (https://en.wikipedia.org/wiki/Kleene_star[Kleene star]), 
porovnÃ¡vÃ¡nÃ­ konÄÃ­ pÅ™i neÃºspÄ›Å¡nÃ©m vyhodnocenÃ­ shody nebo kdyÅ¾ nedojde k posunu vstupem. Pravidlo je vÅ¾dy ÃºspÄ›Å¡nÃ©.

*Syntaxe*

----
any <rule>

<rule> : Parse rule to match zero or more times
----

*PÅ™Ã­klad*

----
letter: charset [#"a" - #"z" #"A" - #"Z"]
digit:  charset [#"0" - #"9"]

parse "Wow, 20 horses at 12,000 RPM!" [
    any "Twin ceramic rotor drives on each wheel!"
    "Wow" any [
        comma any space any digit
        space any letter any [not comma skip]
    ]
]
----

==== `some`

PorovnÃ¡ danÃ© pravidlo nula Äi vÃ­cekrÃ¡t (https://en.wikipedia.org/wiki/Kleene_star#Kleene_plus[Kleene plus]), porovnÃ¡vÃ¡nÃ­ konÄÃ­ pÅ™i neÃºspÄ›Å¡nÃ©m vyhodnocenÃ­ shody nebo kdyÅ¾ nedojde k posunu vstupem. Pravidlo je ÃºspÄ›Å¡nÃ© pÅ™i nalezenÃ­ alespoÅˆ jednÃ© shody.

*Syntaxe*

----
some <rule>

<rule> : Parse rule to match one or more times
----

*PÅ™Ã­klad*

----
parse [
    skidamarink a dink a dink
    skidamarink a doo
][
    some [
        some none 'skidamarink
        [some ['a 'dink] | 'a 'doo]
    ]
]
----

==== `while`

OpakovanÄ› porovnÃ¡vÃ¡ danÃ© pravidlo. ZastavÃ­ se pouze po selhÃ¡nÃ­ pravidla. VÅ¾dycky ÃºspÄ›Å¡nÃ©.

CAUTION: JestliÅ¾e pravidlo neselÅ¾e, uvÃ­zlo `while` v nekoneÄnÃ© smyÄce.

*Syntaxe*

----
while <rule>

<rule> : Parse rule to match repeatedly
----

*PÅ™Ã­klad*

----
parse [throw for a loop][
    while [word! | (print "failed and backtracked on matching the end") [not end] :explicit failure]
    | [while none] :infinite loop
]
----

=== Search

Pravidla search hledajÃ­ urÄenÃ½ vzor prochÃ¡zejÃ­c vstupem aÅ¾ k vÃ½skytu shody.

==== `to`

OpakovanÄ› se pokouÅ¡Ã­ nalÃ©zt shodu s danÃ½m pravidlem aÅ¾ k dosaÅ¾enÃ­ ÃºplnÃ© shody. Pokud Å™eÄenÃ© pravidlo selÅ¾e, postoupÃ­ se vstupem o jeden element, coÅ¾ se poÄÃ­tÃ¡ jako ÄÃ¡steÄnÃ¡ shoda. V pÅ™Ã­padÄ› ÃºplnÃ© shody je pozice vstupu nastavena do Äela (head) posuzovanÃ© ÄÃ¡sti. Succeeds if rule match succeeded.

*Syntaxe*

----
to <rule>

<rule> : Parse rule (pattern to put input position at)
----

*PÅ™Ã­klad*

----
matrix: #{
    416C6C20492073656520697320626C6F6E6465
    2C206272756E657474652C201337526564C0DE
}

parse matrix [
    to #{FACEFEED}
    | to #{1337} #{1337} start: to #{C0DE} end: (print to string! copy/part start end) 2 skip
]
----

==== `thru`

OpakovanÄ› se pokouÅ¡Ã­ nalÃ©zt shodu s danÃ½m pravidlem aÅ¾ k dosaÅ¾enÃ­ ÃºplnÃ© shody. Pokud Å™eÄenÃ© pravidlo selÅ¾e, postoupÃ­ se vstupem o jeden element, coÅ¾ se poÄÃ­tÃ¡ jako ÄÃ¡steÄnÃ¡ shoda. V pÅ™Ã­padÄ› ÃºplnÃ© shody je pozice vstupu nastavena do chvostu (tail) posuzovanÃ© ÄÃ¡sti. Succeeds if rule match succeeded.

*Syntaxe*

----
thru <rule>

<rule> : Parse rule (pattern to advance thru)
----

*PÅ™Ã­klad*

----
parse 'per/aspera/ad/astra [thru 'aspera ad: to 'astra thru end (probe ad)]
----

=== Å˜Ã­zenÃ½ prÅ¯bÄ›h

Å˜Ã­zenÃ½ prÅ¯bÄ›h ovlivÅˆuje pÅ™Ã­mÃ© provedenÃ­ dialektu Parse vloÅ¾enÃ½mi podmÃ­nkami (regulovÄÃ­ky): smyÄkou (<<Repetition>>), zmÄ›nou vstupu, pÅ™edÄasnÃ½m ukonÄenÃ­m a podmÃ­nÄ›nÃ½m porovnÃ¡nÃ­m.

==== `if`

PodmÃ­nÄ›nÃ¡ shoda - je ÃºspÄ›Å¡nÃ¡, kdyÅ¾ se danÃ½ vÃ½raz Redu vyhodnotÃ­ na true. Nikdy se neposune vstupem.

*Syntaxe*

----
if <expression>

<expression> : paren! expression
----

*PÅ™Ã­klad*

----
parse [4 8 15 16 23 42][
    some [mark: skip if (any [even? probe mark/1 find [15 23] first mark])]
]
----

==== `into`

Je-li datovÃ½ typ hodnoty na aktuÃ¡lnÃ­ pozici vstupu podporovÃ¡n dialektem Parse, regulovÄÃ­k `into` doÄasnÄ› pÅ™emÃ­stÃ­ vstup k tÃ©to hodnotÄ› a posoudÃ­ ji z hlediska danÃ©ho pravidla. Po skonÄenÃ©m posouzenÃ­ se vstup vrÃ¡tÃ­ do pÅ¯vodnÃ­ pozice a parsovÃ¡nÃ­ pokraÄuje mimo shodujÃ­cÃ­ se hodnotu.

*Syntaxe*

----
into <rule>

<rule> : block! rule or word! that refers to such rule
----

*PÅ™Ã­klad*

----
rule: [some [word! | into rule]]

parse [we [need [to [go [deeper]]]]] rule
----

==== `fail`

Tento regulovÄÃ­k nutÃ­ pÅ™iloÅ¾enÃ© pravidlo okamÅ¾itÄ› selhat, pokud je umÃ­stÄ›n na jeho konci. Nikdy neuspÄ›je ani nepokroÄÃ­ vstupem.

*PÅ™Ã­klad*

----
parse foo@bar.baz [["quux" | some fail | "foo"] "@" [fail] | thru "bar.baz"]
----

==== `break`

NutÃ­ obklopujÃ­cÃ­ pravidlo `block!` okamÅ¾itÄ› uspÄ›t. UkonÄÃ­ prÅ¯bÄ›h smyÄky, je-li pouÅ¾ito v nejvyÅ¡Å¡Ã­ Ãºrovni <<Repetition, opakovacÃ­ho>> pravidla. VÅ¾dy uspÄ›je a nikdy nepokroÄÃ­ vstupem.

*PÅ™Ã­klad*

----
parse [break away from everything][some [break] 0 1 [break] [2 [break] | 3 word! [break] skip]]
----

==== `reject`

NutÃ­ obklopujÃ­cÃ­ pravidlo `block!` okamÅ¾itÄ› selhat. UkonÄÃ­ prÅ¯bÄ›h smyÄky, je-li pouÅ¾ito v nejvyÅ¡Å¡Ã­ Ãºrovni <<Repetition, opakovacÃ­ho>> pravidla. Nikdy neuspÄ›je a nepokroÄÃ­ vstupem.


*PÅ™Ã­klad*

----
parse quote (I made a choice that I regret) [
    any [reject now] some [5 word! what: reject I see] is
    | :what 'I [[reject get] | skip]
]
----

=== VyjmutÃ­

VyjÃ­macÃ­ (extraction) pravidla kopÃ­rujÃ­ shodnÃ© hodnoty ze vstupnÃ­ch Å™ad.

==== `set`

PÅ™iÅ™adÃ­ danÃ©mu slovu prvnÃ­ hodnotu ve shodujÃ­cÃ­ se ÄÃ¡sti vstupu.

NOTE: Slovu je pÅ™iÅ™azena hodnota `none`, pokud porovnÃ¡vanÃ© pravidlo neposunulo pozici vstupu.

NOTE: Pro vstup typu `binary!` je slovo (word) nastaveno na hodnotu typu `integer!` mezi `0` a `255`.

*Syntaxe*

----
set <word> <rule>

<word> : word! value to set
<rule> : Parse rule
----


*PÅ™Ã­klad*

----
parse "ğŸ©ğŸ•³ï¸" [set hole ahead [2 skip] set donut [to end]]
----

==== `copy`

PÅ™iÅ™adÃ­ danÃ©mu slovu kopii shodujÃ­cÃ­ se ÄÃ¡sti vstupu.

NOTE: Pokud porovnÃ¡vanÃ© pravidlo nepokroÄilo vstupem, je slovu pÅ™iÅ™azena prÃ¡zdÃ¡ Å™ada (series) stejnÃ©ho typu jako vstup.

*Syntaxe*

----
copy <word> <rule>

<word> : word! value to set
<rule> : Parse rule
----

*PÅ™Ã­klad*

----
parse [Huston do you copy?][2 word! copy Huston [2 word!] copy we opt "have a problem"]
----

==== `collect`

ShromÃ¡Å¾dÃ­ hodnoty, konformnÃ­ s pravidly, kterÃ© jsou oznaÄeny klÃ­ÄovÃ½m slovem. UspÄ›je, uspÄ›je-li danÃ© pravidlo - postupujÃ­c mimo konformnÃ­ (matched) ÄÃ¡sti vstupu.

Pravidlo `keep` uspÄ›je, uspÄ›je-li poskytnutÃ© pravidlo - vklÃ¡dajÃ­c konformnÃ­ hodnoty do bloku, vymezenÃ©ho pravidlem `collect`.

NOTE: PouÅ¾itÃ­ klÃ­ÄovÃ©ho slova `keep` bez souvislosti s pravidlem `collect` je zapovÄ›zeno.

*Syntaxe*

----
collect <rule>
collect set <word> <rule>
collect into <word> <rule>
collect after <word> <rule>

<word> : word! value
<rule> : Parse rule
----

Hodnoty jsou implicitnÄ› vklÃ¡dÃ¡ny do chvostu (tail) bloku. Toto chovÃ¡nÃ­ lze zmÄ›nit nÃ­Å¾e popsanÃ½mi volbami.

.`collect` options.
[[collect-options]]
[options="header" cols="1,9"]
|===
| Option | Description
| `set`
| PÅ™iÅ™adÃ­ danÃ©mu slovu blok shromÃ¡Å¾dÄ›nÃ½ch (collected) hodnot.
| `into`
| VloÅ¾Ã­ shromÃ¡Å¾dÄ›nÃ© hodnoty do Å™ady (series), oznaÄenÃ© slovem, pÅ™enese index Å™ady do jejÃ­ho Äela.
| `after`
| VloÅ¾Ã­ shromÃ¡Å¾dÄ›nÃ© hodnoty do Å™ady (series), oznaÄenÃ© slovem, pÅ™emÃ­stÃ­ index Å™ady za vloÅ¾enou ÄÃ¡st.
|===

* Je-li v kterÃ©mkoli pravidlu pouÅ¾it pÅ™Ã­kaz `collect` bez volby `into` Äi `after`, vrÃ¡ti funkce `parse` blok shromÃ¡Å¾dÄ›nÃ½ch hodnot (viz  <<Parsing modes>>); je-li pÅ™Ã­kaz `collect` pouÅ¾it s volbou `set`, vrÃ¡tÃ­ funkce `parse` hodnotu typu `logic!` jako obvykle.
* PrvnÃ­ pouÅ¾itÃ­ pÅ™Ã­kazu `collect` alokuje novÃ½ blok, kterÃ½ je vrÃ¡cen funkcÃ­ `parse`, kaÅ¾dÃ© dalÅ¡Ã­ pouÅ¾itÃ­ pÅ™Ã­kazu `collect` alokuje blok na chvostu (tail) pÅ™edchozÃ­ho bloku; pÅ™Ã­kaz `collect` s volbou `into` Äi `after` pouÅ¾ije jiÅ¾ vytvoÅ™enÃ½ buffer spÃ­Å¡e neÅ¾ alokaci novÃ©ho bloku.

Syntaxe pro `keep`:

----
keep <rule>
keep pick <rule>
keep <expression>
keep pick <expression>

<rule>       : Parse rule
<expression> : paren! expression
----

[[keep-options]]
* JestliÅ¾e porovnÃ¡vanÃ© pravidlo nepokroÄilo vstupem, pÅ™Ã­kaz `keep` nic nezadrÅ¾Ã­.
* JestliÅ¾e pravidlo vyÄlenilo jedinou hodnotu - tato je zadrÅ¾ena (is kept).
* JestliÅ¾e pravidlo vyÄlenilo vÃ­ce hodnot, jsou tyto seskupeny do objektu stejnÃ©ho typu jako vstup; pÅ™i volbÄ› `pick` nejsou hodnoty seskupeny ale uchovÃ¡ny oddÄ›lenÄ›.
* Je-li pÅ™Ã­kaz `keep` pouÅ¾it s vÃ½razem typu `paren!`, je vÃ½sledek jeho vyhodnocenÃ­ uchovÃ¡n tak, jak je.

*Example*

----
fruit: charset [#"^(1F346)" - #"^(1F353)"]
plate: "tropical stuff: ğŸŒğŸ and other healthy food: ğŸ¥’ğŸ…ğŸ¥•"

parse plate [
    collect [
        keep (quote fruits:) collect [some [keep fruit | skip] fail]
        | keep (quote vegetables:) collect [to [#"ğŸ¥’" | "Pickle Rick!"] keep pick [to end]]
    ]
]
----

=== Modifikace

Akce parse mÅ¯Å¾e modifikovat svÃ© vstupy vloÅ¾enÃ­m novÃ½ch hodnot a odebrat Äi zmÄ›nit odpovÃ­dajÃ­cÃ­ ÄÃ¡sti vstupu.

==== `remove`

BuÄ odebere ÄÃ¡st vstupu, konformnÃ­ s danÃ½m pravidlem nebo odebere vstup mezi aktuÃ¡lnÃ­ a zadanou pozicÃ­; zachovÃ¡ pozici na vstupu po jeho redukci.

NOTE: OdebÃ­rÃ¡nÃ­ hodnot je forward-consuming operace. JinÃ½mi slovy, poÄÃ­tÃ¡ se jako shoda, pÅ™esto Å¾e nedojde k pokroÄenÃ­ vstupem.

*Syntaxe*

----
remove <rule>
remove <word>

<rule> : Parse rule
<word> : input postion
----

*PÅ™Ã­klad*

----
parse [remove me <and me also> "but leave me be"][some [remove word!] mark: to string! remove mark skip]
----

==== `insert`

VloÅ¾Ã­ literÃ¡lovou hodnotu nebo vÃ½sledek vyhodnocenÃ­ vÃ½razu do aktuÃ¡lnÃ­ pozice. Akce je vÅ¾dy ÃºspÄ›Å¡nÃ¡ a pokroÄÃ­ vstupem za mÃ­sto vloÅ¾enÃ­.

*Syntaxe*

----
insert <value>
insert <expression>

insert only <value>
insert only <expression>

<value>      : literal value
<expression> : paren! expression
----

Je-li literÃ¡lovÃ¡ hodnota typu `word!`, pouÅ¾ije se hodnota, na nÃ­Å¾ slovo odkazuje. Volba `only` prosadÃ­ sÃ©mantiku `insert/only`.

*PÅ™Ã­klad*

----
parse [assembly][insert [some] skip insert (load "required") insert only [ğŸ—ï¸ ğŸ§°ğŸ‘·]]
----

==== `change`

MÄ›nÃ­ konformnÃ­ (matched) ÄÃ¡st vstupu na literÃ¡lovou hodnotu nebo na vÃ½sledek vyhodnocenÃ­ vÃ½razu. NavÃ­c, mÅ¯Å¾e zmÄ›nit ÄÃ¡st vstupu mezi aktuÃ¡lnÃ­ a oznaÄenou pozicÃ­. Po provedenÃ© zmÄ›nÄ› je akce povaÅ¾ovÃ¡na za ÃºspÄ›Å¡nou a pokroÄÃ­ vstupem za mÄ›nÄ›nou ÄÃ¡st.

*Syntaxe*

----
change <rule> <value>
change <rule> <expression>

change <word> <value>
change <word> <expression>

change only <rule> <value>
change only <rule> <expression>
change only <word> <value>
change only <word> <expression>

<rule>       : Parse rule
<word>       : input position
<value>      : literal value
<expression> : paren! expression
----

Je-li literÃ¡lovÃ¡ hodnota typu `word!`, pouÅ¾ije se jejÃ­ odkazovanÃ¡ hodnota. Volba `only` prosadÃ­ sÃ©mantiku `change/only`.

*PÅ™Ã­klad*

----
parse [some things never change][
    change none (quote and) 2 skip mark: to end change only mark [do]
]
----

== UdÃ¡losti akce parse

Dialekt Parse je implementovÃ¡n jako pushdown automaton (PDA - vyuÅ¾Ã­vajÃ­cÃ­ pamÄ›ti typu stack); pÅ™i kaÅ¾dÃ© zmÄ›nÄ› stavu emituje _event_ (udÃ¡lost s hodnotou typu `word!`), kterÃ¡ informuje uÅ¾ivatele o parsovacÃ­m procesu. Interakce mezi udÃ¡lostmi a internÃ­m stavem aktivity parse je dosaÅ¾eno upÅ™esnÄ›nÃ­m `/trace` a callback funkcÃ­ (viz <<Extra funkce, dalÅ¡Ã­ odstavec>>).

NÃ­Å¾e je uveden seznam vÅ¡ech udÃ¡lostÃ­ s podmÃ­nkami, kterÃ© je vyvolÃ¡vajÃ­ (Å¡tos = stack):

.Seznam udÃ¡lostÃ­ Parse.
[options="header" cols="1,4"]
|===
| Event | Description

| `push`
| PotÃ© co je pravidlo vloÅ¾eno na Å¡tos.

| `pop`
| PÅ™edtÃ­m neÅ¾ je pravidlo staÅ¾eno ze Å¡tosu.

| `fetch`
| PÅ™edtÃ­m neÅ¾ je pÅ™iÅ™azeno novÃ© pravidlo.

| `match`
| PotÃ© co byla nalezena shoda hodnoty s pravidlem.

| `iterate`
| Po zapoÄetÃ­ novÃ©ho iteraÄnÃ­ho kola (viz <<Repetition>>).

| `paren`
| Po vyhodnocenÃ­ vÃ½razu typu `paren!`.

| `end`
| Po dosaÅ¾enÃ­ konce vstupu.

|===

== Extra funkce

VstupnÃ­m bodem do dialektu Parse je nativnÃ­ funkce `parse`, kterÃ¡ pÅ™ijme vstupnÃ­ objekt typu series! a blok s pravidly a podporuje dodateÄnÃ¡ upÅ™esnÄ›nÃ­ (refinements): 

.`parse` refinements.
[options="header" cols="1,3"]
|===
| Refinement | Description
| `/case`
| Enable <<Parsing modes, case-sensitive mode>>.

| `/part`
| Limit parsing up to specified length or input position.

| `/trace`
| Interact with <<Parse events, event-based Parse API>> via provided _callback_.

|===

PÅ™i pouÅ¾itÃ­ upÅ™esnÄ›nÃ­ `/trace` musÃ­ bÃ½t deklarovÃ¡na callback funkce (hodnota typu `function!`) s nÃ¡sledujÃ­cÃ­ specifikacÃ­:

.Callback function specification.
[options="header" cols="1,1,2"]
|===
| Argument | Type | Description

| `event`
| `word!`
| One of the <<Parse events>>.

| `match?`
| `logic!`
| Result of the last match.

| `rule`
| `block!`
| Current rule at current position.

| `input`
| `series!`
| Input series at current position.

| `stack`
| `block!`
| Internal Parse rules stack.

|===

Callback funkce musÃ­ vrÃ¡tit hodnotu typu `logic!`, jeÅ¾ indikuje zda se mÃ¡ v parsovÃ¡nÃ­ pokraÄovat (`true`) Äi nikoli (`false`). 

Za ÃºÄelem ladÄ›nÃ­ je implicitnÄ› poskytnuto zpÄ›tnÃ© volÃ¡nÃ­ (callback) `on-parse-event` a jeho `parse-trace` wrapper.

== ImplementaÄnÃ­ poznÃ¡mky

V tÃ©to ÄÃ¡sti jsou struÄnÄ› zmÃ­nÄ›ny nÄ›kterÃ© Ãºdaje o nÃ¡vrhu a implementaci dialektu Parse.

=== VolnÃ¡ komparace

Jak jiÅ¾ bylo dÅ™Ã­ve zmÃ­nÄ›no, Parse pouÅ¾Ã­vÃ¡ volnou komparaci (loose comparison) pro porovnÃ¡vÃ¡nÃ­ literÃ¡lovÃ½ch hodnot, coÅ¾ je konsistentnÃ­ s Redem.

*PÅ™Ã­klad*

----
parse [I'm 100% <sure>][quote :I'M 1.0 "sure"]
----

=== ProstÃ½ formÃ¡t pravidla

Do jistÃ© mÃ­ry podporuje Parse prostÃ½ (flat) formÃ¡t, pÅ™i nÄ›mÅ¾ jsou pravidla psÃ¡na lineÃ¡rnÄ› jako vÃ½razy s promÄ›nnou aritou, spÃ­Å¡e neÅ¾ s pomocÃ­ vnoÅ™enÃ½ch blokÅ¯.

*PÅ™Ã­klad*

----
parse [on the count of three 1 2 3][collect set stash keep pick to ahead some 1 3 integer! remove any skip]
----

=== OtevÅ™enÃ© problÃ©my

NevyÅ™eÅ¡enÃ© chyby a inkozistence nÃ¡vrhu, souvisejÃ­cÃ­ s dialektem Parse jsou vypsÃ¡ny nÃ­Å¾e:

.NevyÅ™eÅ¡enÃ© problÃ©my.
[options="header" cols="2,6,1"]
|===
| Affected rules | Description | Tickets

| `change <position> <expression>`
| `word!` values are not used literally.
| https://github.com/red/red/issues/4200[#4200]

| `remove <position>`
| The case where position comes after the current one is not handled.
| https://github.com/red/red/issues/4199[#4199]

| `keep pick <expression>`
| Semantics is undefined.
| https://github.com/red/red/issues/4198[#4198]

| `collect into`
| Incorrect handling of series buffer.
| https://github.com/red/red/issues/4197[#4197]

| `into`
| It is possible to match series not supported by Parse.
| https://github.com/red/red/issues/4194[#4194]

| `break`, `reject`
| Preemptive break of <<Repetition>> rules.
| https://github.com/red/red/issues/4193[#4193]

| `insert <word>`
| The rule is not handled properly.
| https://github.com/red/red/issues/4153[#4153]

| `path!`, `remove`, `insert`, `change`
| Usage of `path!` literal value inside rules is forbidden, `path!` values are handled inconsistently by <<Modification>> rules. 
| https://github.com/red/red/issues/4101[#4101], https://github.com/red/red/issues/3528[#3528]

| `fail`, `break`, `reject`
| Design of some <<Control flow>> rules is not finalized.
| https://github.com/red/red/issues/3478[#3478], https://github.com/red/red/issues/3398[#3398]

| `lit-word!`, `lit-path!`
| Case-sensitive comparison is not handled properly.
| https://github.com/red/red/issues/3029[#3029]

|===
