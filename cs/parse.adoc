= Dialekt Parse
:imagesdir: ../images
:toc:
:toc-title:
:toclevels: 3
:numbered:


== Ãšvod


Dialekt Parse je vnoÅ™enÃ½ DSL (domain-specific language) programovacÃ­ho jazyka Red, kterÃ½ umoÅ¾Åˆuje struÄnÃ© a pÅ™esnÃ© porovnÃ¡nÃ­ vstupnÃ­ch Å™ad se zadanÃ½mi gramatickÃ½mi pravidly. ObecnÃ¡ pravidla tohoto dialektu jsou:

* *HledÃ¡nÃ­* - lokalizace zadanÃ½ch vzorÅ¯
* *Validace* - ovÄ›Å™enÃ­ shody vstupu s urÄitou specifikacÃ­
* *VyjmutÃ­* - pÅ™efiltrovÃ¡nÃ­ dat a agregace hodnot (e.g. scraping)
* *Modifikace* - transformace dat (vloÅ¾enÃ­ Äi odejmutÃ­ hodnot a zmÄ›na detekovanÃ½ch ÄÃ¡stÃ­ vstupÅ¯)
* *ZpracovÃ¡nÃ­ jazyka* - pouÅ¾itÃ­ kompilÃ¡torÅ¯, interpretÅ¯ a lexikÃ¡lnÃ­ch analyzÃ¡torÅ¯, zvlÃ¡Å¡tÄ› pro DSL
* *KÃ³dovÃ¡nÃ­ a dekÃ³dovÃ¡nÃ­* - konverze datovÃ½ch formÃ¡tÅ¯ z jednoho do druhÃ©ho.

=== PouÅ¾itÃ­

Proces parsovÃ¡nÃ­ se invokuje funkcÃ­ *parse* s pouÅ¾itÃ­m jednoduchÃ© skladby (podrobnÄ›ji viz sekce <<Extra funkce>>):

----
parse <input> <rules>

<input> : jakÃ¡koli hodnota typu series! kromÄ› image! a vector!
<rules> : hodnota typu block!, obsahujÃ­cÃ­ platnÃ½ dialekt Parse (top-level rule)
----

Funkce `parse` vracÃ­ hodnotu typu `logic!` jako sdÄ›lenÃ­, zda zadanÃ¡ gramatickÃ¡ pravidla byla Äi nebyla v ÃºplnÃ© shodÄ› se zadanÃ½mi ÄÃ¡stmi vstupu.


=== ZÃ¡kladnÃ­ principy

GramatickÃ¡ pravidla definujÃ­ vzory, pouÅ¾itÃ© pro _vyhodnocenÃ­_ vstupnÃ­ch dat. ZÃ¡kladnÃ­ hodnotÃ­cÃ­ krok dialektu Parse je pravidlo _match_, kterÃ© mÃ¡ jeden z tÄ›chto dvou vÃ½stupÅ¯:

* Pokud se zadanÃ© pravidlo _shoduje_ s posuzovanou ÄÃ¡stÃ­ vstupu, je _ÃºspÄ›Å¡nÃ©_ a proces parse _postoupÃ­_ (advance) za konformnÃ­ ÄÃ¡st vstupu (i pravidla);
* Pokud se _neshoduje_, pravidlo _selhÃ¡vÃ¡_ (fails), naÄeÅ¾ se parse _vrÃ¡tÃ­_ (backtracks)  k _alternativnÃ­m_ pravidlÅ¯m - pokud existujÃ­.

HodnocenÃ­ vstupu (parsing) je stÃ¡le se opakujÃ­cÃ­ aplikace tohoto zÃ¡kladnÃ­ho kroku, kterÃ¡ je zastavena jednou z nÃ¡sledujÃ­cÃ­ch dvou ukonÄujÃ­cÃ­ch podmÃ­nek:

* NeÃºspÄ›Å¡nÃ¡ aplikace pravidla: `parse` vracÃ­ `false`, signalizujÃ­ce neshodu
* ÃšplnÃ¡ shoda pravidla s porovnÃ¡vanÃ½m vstupem a vyÄerpÃ¡nÃ­ vstupu (to jest dosaÅ¾enÃ­ konce zkoumanÃ©ho vstupu): `parse` vracÃ­ `true`, signalizujÃ­ce shodu.

[CAUTION]
==== 
Nejsou-li splnÄ›ny ukonÄovacÃ­ podmÃ­nky, mÅ¯Å¾e vstoupit Parse do nekoneÄnÃ© smyÄky.
====


=== GlosÃ¡Å™

Dialekt parse je vylepÅ¡enÃ½ Älen rodiny formÃ¡lnÃ­ch jazykÅ¯ https://en.wikipedia.org/wiki/Parsing_expression_grammar[Parsing Expression Grammar] (PEG), odliÅ¡ujÃ­cÃ­ se Å¡irokou sadou vlastnostÃ­ a hlubokou integracÃ­ s jazykem Red, avÅ¡ak sdÃ­lejÃ­cÃ­ obecnÃ© vÃ½znamy zÃ¡kladnÃ­ch konstrukcÃ­ a operacÃ­:

GramatickÃ¡ pravidla::
    HierarchickÃ© vÃ½razy s prakticky neomezenou skladebnostÃ­. Jejich skladba a sÃ©mantika jsou popsÃ¡ny v sekci <<Pravidla dialektu Parse>>.

PostupovÃ¡nÃ­::
    ProchÃ¡zenÃ­ (advancing) vstupnÃ­ Å™adou postupnÃ½m ovÄ›Å™ovÃ¡nÃ­m shody jednotlivÃ©ho elementu s gramatickÃ½mi pravidly - aÅ¾ ke konci Å™ady nebo k vÃ½skytu neshody.

VyhledÃ¡nÃ­::
    HledÃ¡nÃ­ nÃ¡slednÄ› pouÅ¾itelnÃ©ho pravidla pro uplatnÄ›nÃ­ za ÃºspÄ›Å¡nou shodou (fetching).

Alternace (v PEG popsÃ¡no jako uspoÅ™Ã¡danÃ½ vÃ½bÄ›r)::
    V pÅ™Ã­padÄ› neshody s pravidlem se postupnÄ› pokouÅ¡et o shodu s alternativnÃ­mi pravidly v tÃ©mÅ¾e bloku za znakem `|` ("pipe", "bar", "or else").

NavrÃ¡cenÃ­ (backtracking)::
    ObnovenÃ­ vstupu a pravidel na pozici pÅ™ed selhÃ¡nÃ­m pravidla. OstatnÃ­ zmÄ›ny (vedlejÅ¡Ã­ ÃºÄinky a Ãºpravy vstupu Äi pravidel) zÅ¯stÃ¡vajÃ­.

Possesive matching::
    ParsovacÃ­ pravidla (zejmÃ©na <<OpakovÃ¡nÃ­>>) se vÅ¾dycky snaÅ¾Ã­ posoudit co nejvÃ­ce vstupnÃ­ch dat.

== ReÅ¾imy parsovÃ¡nÃ­

Procedura _parse_ nabÃ­zÃ­ urÄitou flexibilitu provedenÃ­ podporou rÅ¯znÃ½ch reÅ¾imÅ¯.

=== RozliÅ¡enÃ­ malÃ½ch a velkÃ½ch pÃ­smen

ImplicitnÄ› mÃ¡ Parse shodnou sÃ©mantiku jako Red a je _case-insensitive_. RozliÅ¡enÃ­ velkÃ½ch pÃ­smen lze zapnout upÅ™esnÄ›nÃ­m `/case` a zapnout Äi vypnout klÃ­ÄovÃ½m slovem `case`. Slovo `case` mÄ›nÃ­ reÅ¾im srovnÃ¡vÃ¡nÃ­ jenom pro nÃ¡sledujÃ­cÃ­ pravidlo a potÃ© jej vracÃ­ zpÄ›t nezÃ¡visle na ÃºspÄ›ch Äi neÃºspÄ›ch (failure) pravidla.

*Syntaxe*

----
case <word>

<word> : word! value
----

S hodnotou, na nÃ­Å¾ odkazuje word se zachÃ¡zÃ­ jako s logickÃ½m praporkem (flag) podle standardnÃ­ sÃ©mantiky Redu. LogickÃ© `true` umoÅ¾Åˆuje case-sensitivnÃ­ reÅ¾im, zatÃ­mco logickÃ© `false` jej znemoÅ¾Åˆuje.

=== SbÄ›rnÃ½ reÅ¾im

Pravidlo `collect` pÅ™ikazuje, aby `parse` vrÃ¡tilo blok mÃ­sto hodnoty `logic!`. Detaily lze nalÃ©zt v sekci <<VyjmutÃ­>>.

=== Typy vstupu

V zÃ¡vislosti na typu vstupnÃ­ch dat nejsou nÄ›kterÃ¡ pravidla Parse uplatnitelnÃ¡ nebo se chovajÃ­ odliÅ¡nÄ›.

* `any-block!`: porovnÃ¡vÃ¡nÃ­ se sadou znakÅ¯ nemÃ¡ Å¾Ã¡dnÃ½ vÃ½znam a vÅ¾dycky selÅ¾e;
* `any-string!`: porovnÃ¡vÃ¡nÃ­ s datovÃ½m typem nebo sadou typÅ¯ nenÃ­ podporovÃ¡no.
* `binary!`: porovnÃ¡vÃ¡nÃ­ s datovÃ½m typem nebo sadou typÅ¯ je podporovÃ¡no pro hodnoty s kÃ³dovÃ¡nÃ­m UTF-8; takovÃ© porovnÃ¡nÃ­Ã¡ je ÃºspÄ›Å¡nÃ©, pokud porovnÃ¡vanÃ© ÄÃ¡sti vstupu reprezentujÃ­ nÄ›kterou z literÃ¡lovÃ½ch forem datovÃ©ho typu. PrÃ¡zdnÃ© znaky pÅ™ed tokeny jsou automaticky pÅ™eskoÄeny.

*PÅ™Ã­klad*

----
parse to binary! "3 words: matching by datatype" [number! set-word! 3 word!]
---- 	

== Pravidla dialektu Parse

GramatickÃ¡ pravidla v dialektu Parse mohou mÃ­t nÄ›kolik forem a obvykle majÃ­ vnoÅ™enou nebo rekurzivnÃ­ strukturu. KaÅ¾dÃ© pravidlo je jednÃ­m z nÃ¡sledujÃ­cÃ­ch:

* Dialektem rezervovanÃ© _klÃ­ÄovÃ© slovo_, volitelnÄ› nÃ¡sledovanÃ© argumenty nebo moÅ¾nostmi (viz nÃ­Å¾e).
* Hodnota nÄ›kterÃ©ho z nÃ¡sledujÃ­cÃ­ch datovÃ½ch typÅ¯:
    ** `datatype!` nebo `typeset!` - porovnÃ¡vÃ¡ vstupnÃ­ hodnotu s jejÃ­m <<DatovÃ½ typ, typem>>;   
	** `bitset!` - reprezentuje <<ZnakovÃ¡ sada, znakovou sadu>>;
    ** `word!` - odkazuje na _well-formed_ sub-pravidlo;
    ** `lit-word!` nebo `lit-path!` â€” zavedenÃ© zkratky pro <<LiterÃ¡lovÃ¡ hodnota, parsovÃ¡nÃ­>> vstupnÃ­ch hodnot typu `word!` pÅ™Ã­padnÄ› `path!`;
    ** `set-word!` - se pouÅ¾Ã­vÃ¡ k <<OznaÄenÃ­, nastavenÃ­>> slova na aktuÃ¡lnÃ­ vstupnÃ­ pozici;
    ** `get-word!` - <<PÅ™emÃ­stÄ›nÃ­, vrÃ¡tÃ­>> pozici vstupu k mÃ­stu, oznaÄenÃ©m slovem;
    ** `block!` - hodnota, kterÃ¡ obsahuje libovolnÃ½ poÄet sub-pravidel a znakÅ¯ `|`, jeÅ¾ pÅ¯sobÃ­ jako oddÄ›lovaÄe pro alternativnÃ­ pravidla;
    ** `integer!` - hodnota, kterÃ¡ slouÅ¾Ã­ jako poÄÃ­tadlo pro
	<<PoÄet iteracÃ­, opakovÃ¡nÃ­>> pravidla; dvÄ› nÃ¡sledujÃ­cÃ­ hodnoty typu `integer!` oznaÄujÃ­ rozsah moÅ¾nÃ½ch iteracÃ­;
    ** `paren!` - hodnota, kterÃ¡ pÅ¯sobÃ­ jako <<VyhodnocenÃ­ vÃ½razu, ÃºnikovÃ½ mechanizmus>> dialektu vyhodnocenÃ­m obsaÅ¾enÃ©ho vÃ½razu Red a pokraÄovÃ¡nÃ­m v parsovÃ¡nÃ­ vstupu; nÄ›kterÃ¡ klÃ­ÄovÃ¡ slova Parse pouÅ¾Ã­vajÃ­ vrÃ¡cenÃ© hodnoty z vÃ½razu ve shodÄ› se svou vlastnÃ­ sÃ©mantikou;
* JakÃ¡koliv jinÃ¡ literÃ¡lovÃ¡ hodnota vÃ½Å¡e nezmÃ­nÄ›nÃ¡, jeÅ¾ se pouÅ¾Ã­vÃ¡ _tak jak je_ pro pÅ™Ã­mÃ© porovnÃ¡vÃ¡nÃ­ se vstupem.

[NOTE]
==== 
Parse je konsistentnÃ­ s Redem v pouÅ¾Ã­vÃ¡nÃ­ <<VolnÃ© pÅ™irovnÃ¡nÃ­, volnÃ©ho pÅ™irovnÃ¡nÃ­>> pro porovnÃ¡vÃ¡nÃ­ s literÃ¡lovÃ½mi hodnotami.
====

KaÅ¾dÃ© pravidlo (rule) je charakterizovÃ¡no podmÃ­nkami, pÅ™i kterÃ½ch parsovÃ¡nÃ­ pokroÄÃ­ vstupem a uspÄ›je. PÅ™ehled pravidel (jak vyhraÅ¾enÃ¡, tak klÃ­ÄovÃ¡ slova) je tabelÃ¡rnÄ› uveden nÃ­Å¾e.

.PÅ™ehled pravidel dialektu Parse.
[options="header" cols="2,3,2,2"]
|===
| Pravidlo | Categorie | PokroÄÃ­ | UspÄ›je

| `case`
| <<ReÅ¾imy parsovÃ¡nÃ­>>
| Never
| Always

| `block!`
| <<Skladba>>
| Depends
| Depends

| `word!`
| <<Skladba>>
| Depends
| Depends

| literal value
| <<PÅ™Ã­mÃ© posouzenÃ­ shody>>
| Depends
| Depends

| `lit-word!`
| <<PÅ™Ã­mÃ© posouzenÃ­ shody>>
| Depends
| Depends

| `lit-path!`
| <<PÅ™Ã­mÃ© posouzenÃ­ shody>>
| Depends
| Depends

| `datatype!`
| <<PÅ™Ã­mÃ© posouzenÃ­ shody>>
| Depends
| Depends

| `typeset!`
| <<PÅ™Ã­mÃ© posouzenÃ­ shody>>
| Depends
| Depends

| `bitset!`
| <<PÅ™Ã­mÃ© posouzenÃ­ shody>>
| Depends
| Depends

| `quote`
| <<PÅ™Ã­mÃ© posouzenÃ­ shody>>
| Depends
| Depends

| `skip`
| <<PÅ™Ã­mÃ© posouzenÃ­ shody>>
| Depends
| Depends

| `none`
| <<PÅ™Ã­mÃ© posouzenÃ­ shody>>
| Never
| Always

| `end`
| <<PÅ™Ã­mÃ© posouzenÃ­ shody>>
| Never
| Depends

| `opt`
| <<PÅ™edstih>>
| Depends
| Always

| `not`
| <<PÅ™edstih>>
| Never
| Depends

| `ahead`
| <<PÅ™edstih>>
| Never
| Depends

| `paren!`
| <<VyhodnocenÃ­ vÃ½razu>>
| Never
| Always

| `set-word!`
| <<PozicovÃ¡nÃ­>>
| Never
| Always

| `get-word!`
| <<PozicovÃ¡nÃ­>>
| Depends
| Always

| `integer!`
| <<OpakovÃ¡nÃ­>>
| Depends
| Depends

| `any`
| <<OpakovÃ¡nÃ­>>
| Depends
| Always

| `some`
| <<OpakovÃ¡nÃ­>>
| Depends
| Depends

| `while`
| <<OpakovÃ¡nÃ­>>
| Depends
| Always

| `to`
| <<HledÃ¡nÃ­>>
| Depends
| Depends

| `thru`
| <<HledÃ¡nÃ­>>
| Depends
| Depends

| `if`
| <<Å˜Ã­zenÃ½ prÅ¯bÄ›h>>
| Never
| Depends

| `into`
| <<Å˜Ã­zenÃ½ prÅ¯bÄ›h>>
| Depends
| Depends

| `fail`
| <<Å˜Ã­zenÃ½ prÅ¯bÄ›h>>
| Never
| Never

| `break`
| <<Å˜Ã­zenÃ½ prÅ¯bÄ›h>>
| Never
| Always

| `reject`
| <<Å˜Ã­zenÃ½ prÅ¯bÄ›h>>
| Never
| Never

| `set`
| <<VyjmutÃ­>>
| Depends
| Depends

| `copy`
| <<VyjmutÃ­>>
| Depends
| Depends

| `collect`
| <<VyjmutÃ­>>
| Depends
| Depends

| `keep`
| <<VyjmutÃ­>>
| Depends
| Depends

| `remove`
| <<Modifikace>>
| Depends
| Depends

| `insert`
| <<Modifikace>>
| Always
| Always

| `change`
| <<Modifikace>>
| Depends
| Depends

|===

[TIP]
====
VÅ¡echna pravidla v dÃ¡le uvedenÃ½ch odstavcÃ­ch se plnÄ› shodujÃ­ se svÃ½mi vstupy.
====

=== Skladba

Pravidla `block!` pÅ™Ã­mo  seskupujÃ­ ostatnÃ­ prvidla, jsouce prostÅ™edkem pro kombinaci.  Pravidla `word!` nepÅ™Ã­mo odkazujÃ­ na jinÃ¡ pravidla, jsouce tak prostÅ™edkem abstrakce. SpoleÄnÄ› tvoÅ™Ã­ zÃ¡klad mluvnickÃ© skladby dialektu Parse.

Na strukturÃ¡lnÃ­ Ãºrovni je gramatika dialektu Parse sloÅ¾ena ze _sekvencÃ­_ a _alternativ_.

* Sekvence pravidel je skupina nula Äi vÃ­ce pravidel, individuelnÄ› ukonÄenÃ½ch _koncem_ sekvence. Tato sekvence je ÃºspÄ›Å¡nÃ¡, dospÄ›je-li parsovÃ¡nÃ­ (postupnÄ› ÃºspÄ›Å¡nou aplikacÃ­ svÃ½ch sub-pravidel) ke svÃ©mu konci. V pÅ™Ã­padÄ› selhÃ¡nÃ­ nÄ›kterÃ©ho sub-pravidla se proces vrÃ¡tÃ­ (backtracks) na poÄÃ¡tek neÃºspÄ›Å¡nÃ© sekvence.
* Koncem sekvence pravidel je buÄ konec vymezujÃ­cÃ­ho bloku nebo _hraniÄnÃ­_ znak `|` alternativy.
* Alternativa je volitelnÃ¡ sekvence, kterou se Parse pokusÃ­ posoudit v pÅ™Ã­padÄ›, Å¾e pÅ™edchozÃ­ (to jest pÅ™ed hranicÃ­ `|`) sekvence selÅ¾e.

=== PÅ™Ã­mÃ© posouzenÃ­ shody

Pravidla, popsanÃ¡ v tÃ©to ÄÃ¡sti, pÅ™Ã­mo posuzujÃ­ shodu vstupnch dat a slouÅ¾Ã­ jako zÃ¡kladnÃ­ stavebnÃ­ bloky pro sestavovÃ¡nÃ­ sloÅ¾itÄ›jÅ¡Ã­ch pravidel.

==== LiterÃ¡lovÃ¡ hodnota

PosouzenÃ­ shody literÃ¡lovÃ© hodnoty je ÃºspÄ›Å¡nÃ© a vede k pokroÄenÃ­ zadanÃ½m vstupem, je-li posuzovanÃ¡ literÃ¡lovÃ¡ hodnota totoÅ¾nÃ¡ s hodnotou na aktuÃ¡lnÃ­ pozici.

[NOTE] 
====
Parse pouÅ¾Ã­vÃ¡ _volnou komparaci_ pro ovÄ›Å™enÃ­ rovnosti. <<RozliÅ¡enÃ­ malÃ½ch a velkÃ½ch pÃ­smen, Case-sensitivnÃ­ reÅ¾im>> vynucuje porovnÃ¡nÃ­ s rozliÅ¡enÃ­m malÃ½ch a velkÃ½ch pÃ­smen.
====

*PÅ™Ã­klad*

----
parse [today is 5-September-2012 #"," 20.3 degrees/celsius][
    'yesterday 'was | 'today 'is 05/09/12 comma 2030e-2 ['degrees/fahrenheit | 'degrees/celsius]
]
----

[NOTE]
====
Pro porovnÃ¡vÃ¡nÃ­ literÃ¡lovÃ½ch hodnot, vymezenÃ½ch v dialektu Parse, se jako ÃºnikovÃ½ mechanizmus pouÅ¾Ã­vÃ¡ klÃ­ÄovÃ© slovo `quote`.
====

==== DatovÃ½ typ

OvÄ›Å™enÃ­ shody podle datovÃ©ho typu (datatype) je ÃºspÄ›Å¡nÃ© a vede k pokroÄenÃ­ vstupem, pokud je ovÄ›Å™ovanÃ¡ hodnota danÃ©ho typu.

*PÅ™Ã­klad*

----
parse [#a 'bird /is :the word][issue! lit-word! refinement! get-word! word!]
----

[NOTE]
==== 
OvÄ›Å™enÃ­ shody podle datovÃ©ho typu nenÃ­ podporovÃ¡no pro vstup typu `binary!` a typy typesetu `any-string!`. Pravidla jsou popsÃ¡na v sekci <<Typy vstupu>>.
==== 

==== TypovÃ¡ sada

OvÄ›Å™enÃ­ shody podle typovÃ© sady (type set) je ÃºspÄ›Å¡nÃ© a vede k pokroÄenÃ­ vstupem, patÅ™Ã­-li datovÃ½ typ vstupnÃ­ hodnoty k danÃ© typovÃ© sadÄ›.

*PÅ™Ã­klad*

----
banner: [
               |
              [_]
             [___]
            [_____]
    Red programming language
    https://www.red-lang.org
]

parse banner [default! series! any-block! any-list! all-word! any-word! any-type! any-string!]
----

[NOTE]
==== 
OvÄ›Å™enÃ­ shody podle typovÃ© sady nenÃ­ podporovÃ¡no pro vstup typu `binary!` a typy typesetu `any-string!`. Pravidla jsou popsÃ¡na v sekci <<Typy vstupu>>.
====


==== ZnakovÃ¡ sada

Jsou-li vstupnÃ­ data typu `any-string!` nebo `binary!` a vstupnÃ­
hodnotu reprezentuje Unicode Code Point (UCP), kterÃ½ patÅ™Ã­ k danÃ© sadÄ› znakÅ¯, je ovÄ›Å™enÃ­ shody ÃºspÄ›Å¡nÃ© a vede k posunu vstupem. Ve vÅ¡ech ostatnÃ­ch pÅ™Ã­padech je ovÄ›Å™enÃ­ shody neÃºspÄ›Å¡nÃ©.

Podrobnosti o vytvoÅ™enÃ­ datovÃ© sady lze nalÃ©zt v 
https://doc.red-lang.org/cs/datatypes/bitset.html[documentaci] k datovÃ©mu typu `bitset!`.

*PÅ™Ã­klad*

----
animal: charset [#"ğŸ¦¢" #"^(1F418)" 128007]
follow: charset "ğŸš¶ğŸ‘£ğŸš¸"

parse "ğŸ‘£ the white ğŸ‡" [follow " the white " animal]
----

[NOTE]
==== 
Varianty _lowercase/uppercase_ tÃ©hoÅ¾ pÃ­smena majÃ­ rÅ¯znÃ¡ UCP. Z toho vyplÃ½vÃ¡, Å¾e ovÄ›Å™ovÃ¡nÃ­ shody podle znakovÃ© sady je _case-sensitive_ bez ohledu na <<ReÅ¾imy parsovÃ¡nÃ­, reÅ¾im parsovÃ¡nÃ­>>.
====

[NOTE]
==== 
Pro vstup typu `binary!` majÃ­ vÃ½znam pouze hodnoty UCP menÅ¡Ã­ neÅ¾ `255`, protoÅ¾e parsovÃ¡nÃ­ v tomto reÅ¾imu je _byte-granular_.
====

==== `quote`

PÅ¯sobÃ­ jako ÃºnikovÃ½ (escape) mechanizmus ze sÃ©mantiky dialektu Parse doslovnÃ½m ovÄ›Å™enÃ­m shody nÃ¡sledujÃ­cÃ­ hodnoty. Toto pravidlo je ÃºspÄ›Å¡nÃ© a vede k posunu vstupem, jestliÅ¾e je ovÄ›Å™enÃ­ shody ÃºspÄ›Å¡nÃ©.

*Syntaxe*

----
quote <value>

<value> : literal value to match
----

*PÅ™Ã­klad*

----
parse [[integer!] matches 20][quote [integer!] quote matches quote 20]
----

==== `skip`

Shoduje se s libobolnou hodnotou a pokroÄÃ­ vstupem. SelÅ¾e pouze v pÅ™Ã­padÄ›, kdy je pozice vstupu na chvostu (tail), protoÅ¾e tam nenÃ­ co posuzovat.

*PÅ™Ã­klad*

----
parse <ğŸ’“> [skip | the beat]
----

==== `none`

Pravidlo _no-op_ nebo _catch-all_, vÅ¾dy se shoduje a nikdy nevede k postupu vstupem.

*PÅ™Ã­klad*

----
parse reduce [none none][none #(none) ['none | none] none! none]
----

==== `end`

Pravidlo je ÃºspÄ›Å¡nÃ©, je-li pozice vstupu na jeho chvostu (tail) a nikdy nevede k postupu vstupem, protoÅ¾e jiÅ¾ nenÃ­ kam se posouvat.

*PÅ™Ã­klad*

----
parse [(ï¼Šâ—•á´—â—•ï¼Š)][end | skip [skip | end]]
----

=== PÅ™edstih

Pravidla s _pÅ™edstihem_ (look-ahead) nabÃ­zejÃ­ podrobnÄ›jÅ¡Ã­ nastavenÃ­ pro ovÄ›Å™ovÃ¡nÃ­ shody, couvÃ¡nÃ­ (backtracking) a posun vstupu.

==== `opt`

VolitelnÄ› posuzuje shodu s danÃ½m pravidlem, kterÃ¡ vede Äi nevede k posunu vstupem. Pravidlo je vÅ¾dy ÃºspÄ›Å¡nÃ© (== true) bez ohledu na shodu.

*Syntaxe*

----
opt <rule>

<rule> : Parse rule (option) to match
----

*PÅ™Ã­klad*

----
parse "maybe" [opt "or" "may" opt [#"b" #"e"] opt "not"]
----

==== `not`

Toto pravidlo je ÃºspÄ›Å¡nÃ©, jestliÅ¾e zadanÃ© pravidlo selÅ¾e a opaÄnÄ›. Nikdy nevede k posunu vstupem, bez ohledu na shodu Äi neshodu.

*Syntaxe*

----
not <rule>

<rule> : Parse rule to invert
----

*PÅ™Ã­klad*

----
parse [panama][not 'man not ['plan | 'canal] not word! | skip]
----

==== `ahead`

PÅ™ednostnÄ› Å™eÅ¡Ã­ shodu s danÃ½m pravidlem. SelÅ¾e v pÅ™Ã­padÄ› selhÃ¡nÃ­ pravidla, jinak je ÃºspÄ›Å¡nÃ© bez posunu vstupem.

*Syntaxe*

----
ahead <rule>

<rule> : Parse rule to look ahead
----

*PÅ™Ã­klad*

----
parse [great times ahead][ahead ['great 'times] 'great ahead ['times ahead word! 'ahead] 'times skip] 
----

=== VyhodnocenÃ­ vÃ½razu

Pravidlo typu `paren!` obsahuje libovolnÃ½ vÃ½raz Redu, kterÃ½ se v pÅ™Ã­padÄ› shody vyhodnotÃ­. Toto pravidlo je vÅ¾dy ÃºspÄ›Å¡nÃ© ale nevede k postupu vstupem.

*PÅ™Ã­klad*

----
parse [(did it match?)][
    block! (not matched)
    | (probe 'backtracked) quote (did it match?) (probe 'matched!)
]
----

=== PozicovÃ¡nÃ­

Je moÅ¾nÃ© oznaÄit aktuÃ¡lnÃ­ pozici vstupu nebo  _pÅ™ejÃ­t_ (rewind/fast-forward) na jinou pozici v tÃ©Å¾e vstupnÃ­ Å™adÄ›.

==== OznaÄenÃ­

Pravidlo `set-word!` nastavÃ­ slovo k aktuÃ¡lnÃ­ pozici vstupnÃ­ Å™ady. Je vÅ¾dy ÃºspÄ›Å¡nÃ© a nikdy nevede k postupu vstupem.

*PÅ™Ã­klad*

----
check: quote (probe reduce [start :failed before after current end])
match: [before: 'this none after:]

parse [match this input][
    start: quote [false start] failed:
    | ahead [skip match] current: ['match 'this 'input] end: check
]
----

==== PÅ™emÃ­stÄ›nÃ­

Pravidlo `get-word!` nastavÃ­ pozici vstupu do mÃ­sta, oznaÄenÃ©ho zadanÃ½m slovem. Je vÅ¾dy ÃºspÄ›Å¡nÃ© a buÄ posouvÃ¡ vpÅ™ed, zÅ¯stÃ¡vÃ¡ stÃ¡t nebo posouvÃ¡ vzad - v zÃ¡vislosti na postavenÃ­ markeru vzhledem k aktuÃ¡lnÃ­ pozici vstupu.

*PÅ™Ã­klad*

----
phrase: "and so on and so forth, 'til it gets boring"
goes: skip find phrase comma 2
end: tail phrase

parse phrase [again: "and" :again ['it | :goes] "until the" | :end]
----

[NOTE]
==== 
PÅ™emÃ­stÄ›nÃ­ pozice do jinÃ© Å™ady neÅ¾ vstupnÃ­ nenÃ­ dovoleno.
====

=== OpakovÃ¡nÃ­

Pravidla nÃ­Å¾e popsanÃ¡ pÅ¯sobÃ­ pÅ™i posouzenÃ­ shody jako smyÄky nebo iterÃ¡tory buÄ urÄenÃ½m poÄtem opakovÃ¡nÃ­ nebo aÅ¾ do dosaÅ¾enÃ­ neshody.

[NOTE]
==== 
OpakovacÃ­ pravidla majÃ­ vlastnickÃ© chovÃ¡nÃ­ a posoudÃ­ shodu co moÅ¾nÃ¡ nejrozsÃ¡hlejÅ¡Ã­ho vstupu.
====

==== PoÄet iteracÃ­

Provede posouzenÃ­ shody s danÃ½m pravidlem zadanÃ½m poÄtem opakovÃ¡nÃ­. Je-li pouÅ¾ita skladba _range_, je jako ÃºspÄ›Å¡nÃ½ akceptovÃ¡n libovolnÃ½ poÄet shod v zadanÃ©m rozsahu.

*Syntaxe*

----
<count> <rule>
<count> <count> <rule>

<count> : non-negative integer! value or word! referring to such value
<rule>  : Parse rule to match a specified number of times
----

[NOTE]
==== 
PÅ™i pouÅ¾itÃ­ skladby range musÃ­ bÃ½t prvnÃ­ celÃ© ÄÃ­slo (spodnÃ­ mez) menÅ¡Ã­ nebo roven druhÃ©mu celÃ©mu ÄÃ­slu (hornÃ­ mez).
====

*PÅ™Ã­klad*

----
tuple:  [2 word!]
triple: [3 skip]
THX:    1138

parse [G A T T A C A][2 3 tuple triple | 0 thx [triple tuple] 1 tuple 0 triple]
----

==== Rekurze

Pravidla dialektu Parse lze rekurzivnÄ› sklÃ¡dat. ÃšroveÅˆ rekurze je limitovÃ¡na hloubkou internÃ­ pamÄ›ti stack.

*PÅ™Ã­klad*

----
ping: [none pong]
pong: [skip ping | end]

parse https://google.com ping
----

==== `any`

PorovnÃ¡ danÃ© pravidlo nula Äi vÃ­cekrÃ¡t (https://en.wikipedia.org/wiki/Kleene_star[Kleene star]), 
porovnÃ¡vÃ¡nÃ­ konÄÃ­ pÅ™i vÃ½skytu neshody nebo kdyÅ¾ nedojde k posunu vstupem. Pravidlo je vÅ¾dy ÃºspÄ›Å¡nÃ©.

*Syntaxe*

----
any <rule>

<rule> : Parse rule to match zero or more times
----

*PÅ™Ã­klad*

----
letter: charset [#"a" - #"z" #"A" - #"Z"]
digit:  charset [#"0" - #"9"]

parse "Wow, 20 horses at 12,000 RPM!" [
    any "Twin ceramic rotor drives on each wheel!"
    "Wow" any [
        comma any space any digit
        space any letter any [not comma skip]
    ]
]
----

==== `some`

PorovnÃ¡ danÃ© pravidlo jednou Äi vÃ­cekrÃ¡t (https://en.wikipedia.org/wiki/Kleene_star#Kleene_plus[Kleene plus]), porovnÃ¡vÃ¡nÃ­ konÄÃ­ pÅ™i vÃ½skytu neshody nebo kdyÅ¾ nedojde k posunu vstupem. Pravidlo je ÃºspÄ›Å¡nÃ© pÅ™i nalezenÃ­ alespoÅˆ jednÃ© shody.

*Syntaxe*

----
some <rule>

<rule> : Parse rule to match one or more times
----

*PÅ™Ã­klad*

----
parse [
    skidamarink a dink a dink
    skidamarink a doo
][
    some [
        some none 'skidamarink
        [some ['a 'dink] | 'a 'doo]
    ]
]
----

==== `while`

OpakovanÄ› porovnÃ¡vÃ¡ danÃ© pravidlo. ZastavÃ­ se pouze po selhÃ¡nÃ­ pravidla. VÅ¾dycky ÃºspÄ›Å¡nÃ©.

POZOR: JestliÅ¾e pravidlo neselÅ¾e, uvÃ­zlo `while` v nekoneÄnÃ© smyÄce.

*Syntaxe*

----
while <rule>

<rule> : Parse rule to match repeatedly
----

*PÅ™Ã­klad*

----
parse [throw for a loop][
    while [word! | (print "failed and backtracked on matching the end") [not end] :explicit failure]
    | [while none] :infinite loop
]
----

=== HledÃ¡nÃ­

Pravidla tÃ©to skupiny (search) hledajÃ­ urÄenÃ½ vzor prochÃ¡zejÃ­c vstupem aÅ¾ k vÃ½skytu shody.

==== `to`

OpakovanÄ› se pokouÅ¡Ã­ nalÃ©zt shodu s danÃ½m pravidlem aÅ¾ k dosaÅ¾enÃ­ ÃºplnÃ© shody. Pokud Å™eÄenÃ© pravidlo selÅ¾e, postoupÃ­ se vstupem o jeden element, coÅ¾ se poÄÃ­tÃ¡ jako ÄÃ¡steÄnÃ¡ shoda. V pÅ™Ã­padÄ› ÃºplnÃ© shody je pozice vstupu nastavena do Äela (head) posuzovanÃ© ÄÃ¡sti. Succeeds if rule match succeeded.

*Syntaxe*

----
to <rule>

<rule> : Parse rule (pattern to put input position at)
----

*PÅ™Ã­klad*

----
matrix: #{
    416C6C20492073656520697320626C6F6E6465
    2C206272756E657474652C201337526564C0DE
}

parse matrix [
    to #{FACEFEED}
    | to #{1337} #{1337} start: to #{C0DE} end: (print to string! copy/part start end) 2 skip
]
----

==== `thru`

OpakovanÄ› se pokouÅ¡Ã­ nalÃ©zt shodu s danÃ½m pravidlem aÅ¾ k dosaÅ¾enÃ­ ÃºplnÃ© shody. Pokud Å™eÄenÃ© pravidlo selÅ¾e, postoupÃ­ se vstupem o jeden element, coÅ¾ se poÄÃ­tÃ¡ jako ÄÃ¡steÄnÃ¡ shoda. V pÅ™Ã­padÄ› ÃºplnÃ© shody je pozice vstupu nastavena do chvostu (tail) posuzovanÃ© ÄÃ¡sti. Succeeds if rule match succeeded.

*Syntaxe*

----
thru <rule>

<rule> : Parse rule (pattern to advance thru)
----

*PÅ™Ã­klad*

----
parse 'per/aspera/ad/astra [thru 'aspera ad: to 'astra thru end (probe ad)]
----

=== Å˜Ã­zenÃ½ prÅ¯bÄ›h

Pravidla tÃ©to skupiny (control flow) reguluje provedenÃ­ procesu Parse smyÄkami (<<OpakovÃ¡nÃ­>>), zmÄ›nou vstupu, pÅ™edÄasnÃ½m ukonÄenÃ­m a podmÃ­nÄ›nÃ½m porovnÃ¡nÃ­m.

==== `if`

PodmÃ­nÄ›nÃ¡ shoda - je ÃºspÄ›Å¡nÃ¡, kdyÅ¾ se danÃ½ vÃ½raz Redu vyhodnotÃ­ na true. Nikdy se neposune vstupem.

*Syntaxe*

----
if <expression>

<expression> : paren! expression
----

*PÅ™Ã­klad*

----
parse [4 8 15 16 23 42][
    some [mark: skip if (any [even? probe mark/1 find [15 23] first mark])]
]
----

==== `into`

Je-li datovÃ½ typ hodnoty na aktuÃ¡lnÃ­ pozici vstupu podporovÃ¡n dialektem Parse, pravidlo `into` doÄasnÄ› pÅ™emÃ­stÃ­ vstup k tÃ©to hodnotÄ› a posoudÃ­ ji z hlediska danÃ©ho pravidla. Po skonÄenÃ©m posouzenÃ­ se vstup vrÃ¡tÃ­ do pÅ¯vodnÃ­ pozice a parsovÃ¡nÃ­ pokraÄuje za shodujÃ­cÃ­ se hodnotou.

*Syntaxe*

----
into <rule>

<rule> : block! rule or word! that refers to such rule
----

*PÅ™Ã­klad*

----
rule: [some [word! | into rule]]

parse [we [need [to [go [deeper]]]]] rule
----

==== `fail`

Tento pÅ™Ã­kaz vynutÃ­ neshodu s pravidlem, pokud je umÃ­stÄ›n na jeho konci. Nikdy neuspÄ›je ani nepokroÄÃ­ vstupem.

*PÅ™Ã­klad*

----
parse foo@bar.baz [["quux" | some fail | "foo"] "@" [fail] | thru "bar.baz"]
----

==== `break`

VynutÃ­ okamÅ¾itou shodu aktuÃ¡lnÃ­ho pravidla `block!`. UkonÄÃ­ prÅ¯bÄ›h smyÄky, je-li pouÅ¾ito v nejvyÅ¡Å¡Ã­ Ãºrovni <<OpakovÃ¡nÃ­, opakovacÃ­ho>> pravidla. VÅ¾dy uspÄ›je a nikdy nepokroÄÃ­ vstupem.

*PÅ™Ã­klad*

----
parse [break away from everything][some [break] 0 1 [break] [2 [break] | 3 word! [break] skip]]
----

==== `reject`

VynutÃ­ okamÅ¾itou neshodu aktuÃ¡lnÃ­ho pravidla `block!`. UkonÄÃ­ prÅ¯bÄ›h smyÄky, je-li pouÅ¾ito v nejvyÅ¡Å¡Ã­ Ãºrovni <<OpakovÃ¡nÃ­, opakovacÃ­ho>> pravidla. Nikdy neuspÄ›je a nepokroÄÃ­ vstupem.


*PÅ™Ã­klad*

----
parse quote (I made a choice that I regret) [
    any [reject now] some [5 word! what: reject I see] is
    | :what 'I [[reject get] | skip]
]
----

=== VyjmutÃ­

VyjÃ­macÃ­ (extraction) pravidla kopÃ­rujÃ­ shodnÃ© hodnoty ze vstupnÃ­ch Å™ad.

==== `set`

PÅ™iÅ™adÃ­ danÃ© slovo prvnÃ­ hodnotÄ› v konformnÃ­ ÄÃ¡sti vstupu.

[NOTE]
==== 
Slovu je pÅ™iÅ™azena hodnota `none`, pokud porovnÃ¡vanÃ© pravidlo neposunulo pozici vstupu.
====

[NOTE]
==== 
Pro vstup typu `binary!` je slovo nastaveno na hodnotu typu `integer!` mezi `0` a `255`.
[NOTE]
====

*Syntaxe*

----
set <word> <rule>

<word> : word! value to set
<rule> : Parse rule
----


*PÅ™Ã­klad*

----
parse "ğŸ©ğŸ•³ï¸" [set hole ahead [2 skip] set donut [to end]]
----

==== `copy`

PÅ™iÅ™adÃ­ danÃ© slovo kopii shodujÃ­cÃ­ se ÄÃ¡sti vstupu.

NOTE: Pokud porovnÃ¡vanÃ© pravidlo nepokroÄilo vstupem, je slovu pÅ™iÅ™azena prÃ¡zdÃ¡ Å™ada (series) stejnÃ©ho typu jako vstup.

*Syntaxe*

----
copy <word> <rule>

<word> : word! value to set
<rule> : Parse rule
----

*PÅ™Ã­klad*

----
parse [Huston do you copy?][2 word! copy Huston [2 word!] copy we opt "have a problem"]
----

==== `collect`

ShromÃ¡Å¾dÃ­ konformnÃ­ hodnoty, kterÃ© jsou oznaÄeny klÃ­ÄovÃ½m slovem `keep`. UspÄ›je, uspÄ›je-li danÃ© pravidlo - postupujÃ­c za konformnÃ­ (matched) ÄÃ¡st vstupu.

Pravidlo `keep` uspÄ›je, uspÄ›je-li poskytnutÃ© pravidlo - vklÃ¡dajÃ­c konformnÃ­ hodnoty do bloku, vymezenÃ©ho pravidlem `collect`.

[NOTE]
==== 
PouÅ¾itÃ­ klÃ­ÄovÃ©ho slova `keep` bez souvislosti s pravidlem `collect` je zapovÄ›zeno.
====

*Syntaxe*

----
collect <rule>
collect set <word> <rule>
collect into <word> <rule>
collect after <word> <rule>

<word> : word! value
<rule> : Parse rule
----

Hodnoty jsou implicitnÄ› vklÃ¡dÃ¡ny do chvostu (tail) bloku. Toto chovÃ¡nÃ­ lze zmÄ›nit nÃ­Å¾e popsanÃ½mi volbami.

.Volby pro pravidlo `collect`.
[[collect-options]]
[options="header" cols="1,9"]
|===
| Volba | Popis
| `set`
| PÅ™iÅ™adÃ­ danÃ©mu slovu blok shromÃ¡Å¾dÄ›nÃ½ch (collected) hodnot.
| `into`
| VloÅ¾Ã­ shromÃ¡Å¾dÄ›nÃ© hodnoty do Å™ady (series), oznaÄenÃ© slovem, pÅ™enese index Å™ady do jejÃ­ho Äela.
| `after`
| VloÅ¾Ã­ shromÃ¡Å¾dÄ›nÃ© hodnoty do Å™ady (series), oznaÄenÃ© slovem, pÅ™emÃ­stÃ­ index Å™ady za vloÅ¾enou ÄÃ¡st.
|===

* Je-li v kterÃ©mkoli pravidlu pouÅ¾it pokyn `collect` bez volby `into` Äi `after`, vrÃ¡ti funkce `parse` blok shromÃ¡Å¾dÄ›nÃ½ch hodnot (viz <<ReÅ¾imy parsovÃ¡nÃ­>>); je-li pokyn `collect` pouÅ¾it s volbou `set`, vrÃ¡tÃ­ funkce `parse` hodnotu typu `logic!` jako obvykle.
* PrvnÃ­ pouÅ¾itÃ­ pokynu `collect` alokuje novÃ½ blok, kterÃ½ je vrÃ¡cen funkcÃ­ `parse`, kaÅ¾dÃ© dalÅ¡Ã­ pouÅ¾itÃ­ pokynu `collect` alokuje hodnoty (blok) na chvostu (tail) pÅ™edchozÃ­ho bloku; pokyn `collect` s volbou `into` Äi `after` pouÅ¾ije jiÅ¾ vytvoÅ™enÃ½ buffer spÃ­Å¡e neÅ¾ alokaci novÃ©ho bloku.

Syntaxe pro `keep`:

----
keep <rule>
keep pick <rule>
keep <expression>
keep pick <expression>

<rule>       : Parse rule
<expression> : paren! expression
----

[[keep-options]]
* JestliÅ¾e porovnÃ¡vanÃ© pravidlo nepokroÄilo vstupem, pÅ™Ã­kaz `keep` nic nezadrÅ¾Ã­.
* JestliÅ¾e pravidlo vyÄlenilo jedinou hodnotu - tato je zadrÅ¾ena (is kept).  Je-li `keep` nÃ¡sledovÃ¡no pravidlem `copy`, potom je posuzovanÃ¡ hodnota pÅ™iÅ™azena stejnÃ©mu typu z typesetu `series` jako vstup.
* JestliÅ¾e pravidlo vyÄlenilo vÃ­ce hodnot, jsou tyto seskupeny do objektu stejnÃ©ho typu jako vstup; pÅ™i volbÄ› `pick` nejsou hodnoty seskupeny ale uchovÃ¡ny oddÄ›lenÄ›.
* Je-li pÅ™Ã­kaz `keep` pouÅ¾it s vÃ½razem typu `paren!`, je vÃ½sledek jeho vyhodnocenÃ­ uchovÃ¡n tak, jak je.

*Example*

----
fruit: charset [#"^(1F346)" - #"^(1F353)"]
plate: "tropical stuff: ğŸŒğŸ and other healthy food: ğŸ¥’ğŸ…ğŸ¥•"

parse plate [
    collect [
        keep (quote fruits:) collect [some [keep fruit | skip] fail]
        | keep (quote vegetables:) collect [to [#"ğŸ¥’" | "Pickle Rick!"] keep pick [to end]]
    ]
]
----

=== Modifikace

Akce parse mÅ¯Å¾e modifikovat svÃ© vstupy vloÅ¾enÃ­m novÃ½ch hodnot a odebrat Äi zmÄ›nit odpovÃ­dajÃ­cÃ­ ÄÃ¡sti vstupu.

==== `remove`

BuÄ odebere ÄÃ¡st vstupu, konformnÃ­ s danÃ½m pravidlem nebo odebere vstup mezi aktuÃ¡lnÃ­ a zadanou pozicÃ­; potÃ© zachovÃ¡ aktuÃ¡lnÃ­ vstupnÃ­ pozici.

[NOTE]
==== 
OdebÃ­rÃ¡nÃ­ hodnot je "forward-consuming" operace. JinÃ½mi slovy, poÄÃ­tÃ¡ se jako shoda, pÅ™esto Å¾e nedojde k pokroÄenÃ­ vstupem.
====

*Syntaxe*

----
remove <rule>
remove <word>

<rule> : Parse rule
<word> : input postion
----

*PÅ™Ã­klad*

----
parse [remove me <and me also> "but leave me be"][some [remove word!] mark: to string! remove mark skip]
----

==== `insert`

VloÅ¾Ã­ literÃ¡lovou hodnotu nebo vÃ½sledek vyhodnocenÃ­ vÃ½razu  buÄ do aktuÃ¡lnÃ­ nebo zadanÃ© (marked) pozice. Akce je vÅ¾dy ÃºspÄ›Å¡nÃ¡ a pokroÄÃ­ vstupem za mÃ­sto vloÅ¾enÃ­, pokud byla provedena v aktuÃ¡lnÃ­ pozici, jinak je zachovÃ¡na vstupnÃ­ pozice.

*Syntaxe*

----
insert <value>
insert <expression>

insert <word> <value>
insert <word> <expression>

insert only <value>
insert only <expression>

insert only <word> <value>
insert only <word> <expression>

<word>       : input position
<value>      : literal value
<expression> : paren! expression
----

Je-li literÃ¡lovÃ¡ hodnota typu `word!`, pouÅ¾ije se hodnota, na nÃ­Å¾ slovo odkazuje. Volba `only` prosadÃ­ sÃ©mantiku `insert/only`.

*PÅ™Ã­klad*

----
ikea: [assembly]
here: tail ikea

parse ikea [
	insert only here [ğŸ—ï¸ ğŸ§°ğŸ‘·]
	insert only (load "[manual]")
	word!
	insert ikea [some]
	block!
	insert [required]
]
----

==== `change`

MÄ›nÃ­ konformnÃ­ (matched) ÄÃ¡st vstupu na literÃ¡lovou hodnotu nebo na vÃ½sledek vyhodnocenÃ­ vÃ½razu. NavÃ­c, mÅ¯Å¾e zmÄ›nit ÄÃ¡st vstupu mezi aktuÃ¡lnÃ­ a oznaÄenou pozicÃ­. Byla-li zmÄ›na provedena v aktuÃ¡lnÃ­ pozici, je ÃºspÄ›Å¡nÃ¡ a posune vstup za upravovanou ÄÃ¡st; v opaÄnÃ©m pÅ™Ã­padÄ› je vstupnÃ­ pozice zachovÃ¡na.

*Syntaxe*

----
change <rule> <value>
change <rule> <expression>

change <word> <value>
change <word> <expression>

change only <rule> <value>
change only <rule> <expression>
change only <word> <value>
change only <word> <expression>

<rule>       : Parse rule
<word>       : input position
<value>      : literal value
<expression> : paren! expression
----

Je-li literÃ¡lovÃ¡ hodnota typu `word!`, pouÅ¾ije se jejÃ­ odkazovanÃ¡ hodnota. Volba `only` prosadÃ­ sÃ©mantiku `change/only`.

*PÅ™Ã­klad*

----
parse [some things never change][
    change none (quote and) 2 skip mark: to end change only mark [do]
]
----

== UdÃ¡losti procesu parse

Dialekt Parse je implementovÃ¡n jako "pushdown automaton" (PDA), vyuÅ¾Ã­vajÃ­cÃ­ pamÄ›ti typu stack. PÅ™i kaÅ¾dÃ© zmÄ›nÄ› stavu emituje _udÃ¡lost_ (event, hodnota typu `word!`), kterÃ¡ informuje uÅ¾ivatele o parsovacÃ­m procesu. Interakce mezi udÃ¡lostmi a internÃ­m stavem aktivity parse je dosaÅ¾eno upÅ™esnÄ›nÃ­m `/trace` a "callback" funkcÃ­ (viz <<Extra funkce, dalÅ¡Ã­ odstavec>>).

NÃ­Å¾e je uveden seznam vÅ¡ech udÃ¡lostÃ­ s podmÃ­nkami, kterÃ© je vyvolÃ¡vajÃ­ (Å¡tos = stack):

.Seznam udÃ¡lostÃ­ Parse.
[options="header" cols="1,4"]
|===
| UdÃ¡lost | Popis

| `push`
| PotÃ© co je pravidlo vloÅ¾eno na Å¡tos.

| `pop`
| PÅ™edtÃ­m neÅ¾ je pravidlo staÅ¾eno ze Å¡tosu.

| `fetch`
| PÅ™edtÃ­m neÅ¾ je pÅ™iÅ™azeno novÃ© pravidlo.

| `match`
| PotÃ© co byla nalezena shoda hodnoty s pravidlem.

| `iterate`
| Po zapoÄetÃ­ novÃ©ho iteraÄnÃ­ho kola (viz <<OpakovÃ¡nÃ­>>).

| `paren`
| Po vyhodnocenÃ­ vÃ½razu typu `paren!`.

| `end`
| Po dosaÅ¾enÃ­ konce vstupu.

|===

== Extra funkce

VstupnÃ­m bodem do dialektu Parse je nativnÃ­ funkce `parse`, kterÃ¡ pÅ™ijme vstupnÃ­ *objekt* typu series!, *blok* s pravidly a kterÃ¡ podporuje dodateÄnÃ¡ upÅ™esnÄ›nÃ­ (refinements): 

.`parse` refinements.
[options="header" cols="1,3"]
|===
| Refinement | Description
| `/case`
| UmoÅ¾nit <<ReÅ¾imy parsovÃ¡nÃ­, case-sensitive reÅ¾im>>.

| `/part`
| Limitovat parsovÃ¡nÃ­ urÄenou dÃ©lkou nebo pozicÃ­ vstupu.

| `/trace`
| SpolupÅ¯sobit s <<UdÃ¡losti procesu parse, rozhranÃ­m PDA>> pÅ™es zadanÃ½ _callback_.

|===

PÅ™i pouÅ¾itÃ­ upÅ™esnÄ›nÃ­ `/trace` musÃ­ bÃ½t urÄena funkce "zpÄ›tnÃ©ho volÃ¡nÃ­ " (callback, hodnota typu `function!`) s nÃ¡sledujÃ­cÃ­ specifikacÃ­:

.Callback function specification.
[options="header" cols="1,1,2"]
|===
| Argument | Type | Description

| `event`
| `word!`
| NÄ›kterÃ¡ z <<UdÃ¡losti procesu parse>>.

| `match?`
| `logic!`
| VÃ½sledek poslednÃ­ shody

| `rule`
| `block!`
| AktuÃ¡lnÃ­ pravidlo v aktuÃ¡lnÃ­ pozici.

| `input`
| `series!`
| VstupnÃ­ objekt ze sady series! v aktuÃ¡lnÃ­ pozcici


| `stack`
| `block!`
| InternÃ­ `stack` pravidel Parse.

|===

Callback funkce musÃ­ vrÃ¡tit hodnotu typu `logic!`, jeÅ¾ indikuje, zda se mÃ¡ v parsovÃ¡nÃ­ pokraÄovat (`true`) Äi nikoli (`false`). 

Za ÃºÄelem ladÄ›nÃ­ je implicitnÄ› poskytnuto zpÄ›tnÃ© volÃ¡nÃ­ (callback) `on-parse-event` a jeho `parse-trace` wrapper.

== ImplementaÄnÃ­ poznÃ¡mky

V tÃ©to ÄÃ¡sti jsou struÄnÄ› zmÃ­nÄ›ny nÄ›kterÃ© Ãºdaje o nÃ¡vrhu a implementaci dialektu Parse.

=== VolnÃ© pÅ™irovnÃ¡nÃ­

Jak jiÅ¾ bylo dÅ™Ã­ve zmÃ­nÄ›no, Parse pouÅ¾Ã­vÃ¡ volnÃ© pÅ™irovnÃ¡nÃ­ (loose comparison) pro porovnÃ¡vÃ¡nÃ­ literÃ¡lovÃ½ch hodnot, coÅ¾ je konsistentnÃ­ s Redem.

*PÅ™Ã­klad*

----
parse [I'm 100% <sure>][quote :I'M 1.0 "sure"]
----

=== ProstÃ½ formÃ¡t pravidla

Do jistÃ© mÃ­ry podporuje Parse prostÃ½ (flat) formÃ¡t, pÅ™i nÄ›mÅ¾ jsou pravidla psÃ¡na lineÃ¡rnÄ› jako vÃ½razy s promÄ›nnou aritou, spÃ­Å¡e neÅ¾ s pomocÃ­ vnoÅ™enÃ½ch blokÅ¯.

*PÅ™Ã­klad*

----
parse [on the count of three 1 2 3][collect set stash keep pick to ahead some 1 3 integer! remove any skip]
----

=== OtevÅ™enÃ© problÃ©my

NevyÅ™eÅ¡enÃ© chyby a inkozistence nÃ¡vrhu, souvisejÃ­cÃ­ s dialektem Parse jsou vypsÃ¡ny nÃ­Å¾e:

.NevyÅ™eÅ¡enÃ© problÃ©my.
[options="header" cols="2,6,1"]
|===
| Affected rules | Description | Tickets

| `remove <position>`
| The case where position comes after the current one is not handled.
| https://github.com/red/red/issues/4199[#4199]

| `break`, `reject`
| Preemptive break of <<Repetition>> rules.
| https://github.com/red/red/issues/4193[#4193]

| `fail`, `break`, `reject`
| Design of some <<Control flow>> rules is not finalized.
| https://github.com/red/red/issues/3478[#3478], https://github.com/red/red/issues/3398[#3398]

| `lit-word!`, `lit-path!`
| Case-sensitive comparison is not handled properly.
| https://github.com/red/red/issues/3029[#3029]

|===

== PoznÃ¡mka k pÅ™ekladu

KromÄ› anglickÃ½ch i obecnÄ› cizÃ­ch slov jsou v pÅ™ekladu pouÅ¾ity jistÃ© rÃ¡doby ekvivalentnÃ­ vÃ½razy, na nÄ›Å¾ chci zde upozornit:

* series! - Å™ada - vstup - vstupnÃ­ objekt, nÃ¡leÅ¾ejÃ­cÃ­ do typovÃ© sady series! pÅ™Ã­padnÄ› nÃ¡zev pravidla Parse
* matched - konformnÃ­ - shodujÃ­cÃ­ se s pravidlem
* top-level-rule ? - Å™Ã­dÃ­cÃ­ pravidlo

