= Char! 数据类型
Version: Draft 3
:toc:
:toc-title: 目录
:numbered:

== 摘要

`char!` 值代表 Unicode 代码点，是十六进制下取值范围在 00 到 10FFFF（十进制下 0 到 111,4111）的整数。

== 特点

`char!` 值是 "`直接的`"、"`原子的`" 和 "`被动的`"。

[NOTE, caption=注意]
====
这里假设类型特点已经在前面的文档中被定义过了。
====

== 创建

`char!` 值可以通过字面语法，或在运行时使用 `make` 构造器或 `to` 转换，或使用能作用于 `string!` 值并提取出 `char!` 值的许多函数之一来创建。

=== 字面语法

`char!` 值的基本字面格式为：

[source, red]
----
#"<character>"
<character> : 单个 Unicode 代码点（它通常是通过按键输入的）
----

这个字面语法也支持 "`转义的`" 字符，用于控制字符和那些无法简单地录入的字符。

Red 中的转义字符是 `^` —— 代码点 U+005E。这导致 `^` 字符本身必须要被转义。该代码点的字符串字面值是 `#"^^"` 而不是 `#"^"`。其实 `#"^"` 是无效的。

在 Red 中有三种转义字符的字面量，一个用于数字代码点，另一个用于命名字符，还有一个用于 "`控制`" 字符。

代码点的形式为：

[source, red]
----
#"^(<codepoint>)"
<codepoint> : 有效的十六进制整数，如 00、ABCD、10FFFFF
----

"`控制`" 字符的形式为：

[source, red]
----
#"^<cc>"
<cc> : 集合 A-Z, [, \, ], _ 中的单个字符
----

[caption="表 1. "]
.转义控制字符
[cols="2*"]
|===

|转义字符
|代码点

|`#"^A" - #"^Z"`
|U+0001 - U+001A

|`#"^["`
|U+001B

|`#"^\"`
|U+001C

|`#"^]"`
|U+001D

|`#"^_"`
|U+001F

|===

"`命名`" 字符形式为：

[source, red]
----
#"^(<name>)" 或 #"^<symbol>" 
<name>   : 命名转义字符表中的名称
<symbol> : 命名转义字符表中的符号
----

[caption="表 2. "]
.命名转义字符
[cols="4*"]
|===

|名称
|符号
|字符
|代码点

|`#"^(null)`
|`#"^@"`
|空字符
|U+0000

|`#"^(back)"`
|
|退格符
|U+0008

|`#"^(tab)"`
|`#"^-"`
|水平制表符
|U+0009

|`#"^(line)"`
|`#"^/"`
|换行符
|U+000A 

|`#"^(page)"`
|
|换页符
|U+000C

|`#"^(esc)"`
|
|退出符
|U+001B

|`#"^(del)"`
|`#"^~"`
|删除符
|U+007F

|
|`#"^""`
|" - 双引号字符
|U+0022

|
|#"^^"
|^ - 脱字符
|U+005E

|===

== 比较

所有比较器都可以应用于 `char!` 值上：`=`、`==`、`<>`、`>`、`<`、`>=`、`&lt;=`、`same?`。另外，也支持 `min`、`max` 和 `sort`。

*例*

[source, red]
----
#"a" = #"A"
== false
same? #"a" #"a"
== true
max #"a" #"A"
== #"a"
sort [#"c" #"b" #"d" #"a"]
== [#"a" #"b" #"c" #"d"]
----

== 算术运算

全系列数学函数都可以用于 `char!` 值。如果算术运算的结果落在取值范围 00 - 10FFFF（十六进制）之外，就会报 `Math Error` 错误。

*例*

[source, red]
----
#"a" + 1
== #"b"
#"a" - 32
== #"A"
#"a" * 256
== #"愀"
#"a" - 98
*** Math Error: math or number overflow
*** Where: -
*** Stack:  
----

== 其他字符相关的函数

`lowercase`、`uppercase`
